import { DiceReducer, DiceBinOp, die, LowHigh, DiceUnOp } from './dice-expression';
import { keepResult, discardResult, rerolled, normal, exploded, diceMapeableResult, diceReduceResult, diceFilterableResult, diceExpressionsResult, binaryOpResult, literalResult, dieResult, unaryOpResult } from './roll-result';
import { oneResult } from './roll-result';
import { RR } from './roll-result-domain';
function mapNotNull(arr, fn) {
    const result = [];
    for (const t of arr) {
        const v = fn(t);
        if (v !== null) {
            result.push(v);
        }
    }
    return result;
}
function compareNumbers(a, b) {
    return a - b;
}
function median(arr) {
    const sorted = arr.slice().sort(compareNumbers);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) {
        return (sorted[mid] + sorted[mid - 1]) / 2;
    }
    else {
        return sorted[mid];
    }
}
function rank(array, compare, incrementDuplicates = true) {
    const arr = array.map((v, i) => [v, i]);
    arr.sort((a, b) => compare(a[0], b[0]));
    const ranks = new Array(arr.length);
    let rank = 0;
    let last = arr[0][0];
    for (let i = 0; i < arr.length; i++) {
        const [v, index] = arr[i];
        if (compare(v, last) !== 0) {
            rank = i;
            last = v;
        }
        ranks[index] = rank;
        if (incrementDuplicates)
            rank++;
    }
    return ranks;
}
export class Roller {
    dieRoll;
    static matchRange(r, range) {
        switch (range.type) {
            case 'exact':
                return compareNumbers(r, range.value) === 0;
            case 'between':
                return compareNumbers(r, range.minInclusive) >= 0 && compareNumbers(r, range.maxInclusive) <= 0;
            case 'value-or-more':
                return compareNumbers(r, range.value) >= 0;
            case 'value-or-less':
                return compareNumbers(r, range.value) <= 0;
            case 'composite':
                return range.ranges.some(range => Roller.matchRange(r, range));
        }
    }
    static filterf(filter) {
        switch (filter.type) {
            case 'drop':
                if (filter.dir === LowHigh.Low) {
                    return (res) => res >= filter.value;
                }
                else {
                    return (res, length) => res < length - filter.value;
                }
            case 'keep':
                if (filter.dir === LowHigh.High) {
                    return (res, length) => res >= length - filter.value;
                }
                else {
                    return (res) => res < filter.value;
                }
        }
    }
    constructor(dieRoll) {
        this.dieRoll = dieRoll;
    }
    rollDiceReduce(dr) {
        if (dr.reduceable.type === 'dice-expressions') {
            const rolls = dr.reduceable.exprs.map(expr => this.roll(expr));
            const result = this.reduceRolls(rolls, dr.reducer);
            return diceReduceResult(diceExpressionsResult(rolls), dr.reducer, result);
        }
        else if (dr.reduceable.type === 'dice-list-with-filter') {
            if (dr.reduceable.list.type === 'filterable-dice-array') {
                const rolls = dr.reduceable.list.dice.map(d => this.roll(die(d)));
                const filteredRolls = this.filterRolls(rolls, dr.reduceable.filter);
                const keepFilteredRolls = this.keepFilteredRolls(filteredRolls);
                const result = this.reduceRolls(keepFilteredRolls, dr.reducer);
                return diceReduceResult(diceFilterableResult(filteredRolls, dr.reduceable.filter), dr.reducer, result);
            }
            else if (dr.reduceable.list.type === 'filterable-dice-expressions') {
                const rolls = dr.reduceable.list.exprs.map(expr => this.roll(expr));
                const filteredRolls = this.filterRolls(rolls, dr.reduceable.filter);
                const keepFilteredRolls = this.keepFilteredRolls(filteredRolls);
                const result = this.reduceRolls(keepFilteredRolls, dr.reducer);
                return diceReduceResult(diceFilterableResult(filteredRolls, dr.reduceable.filter), dr.reducer, result);
            }
            else {
                throw new Error(`Unknown filterable: ${JSON.stringify(dr)}`);
            }
        }
        else if (dr.reduceable.type === 'dice-list-with-map') {
            const rolls = dr.reduceable.dice.map(d => {
                const roll = this.roll(die(d));
                if (roll.type === 'one-result') {
                    return roll.die;
                }
                else {
                    throw new Error(`Expected die result, got ${JSON.stringify(roll)}`);
                }
            });
            const mapped = this.mapRolls(rolls, dr.reduceable.functor);
            const keepMappedRolls = this.keepMappedRolls(mapped);
            const result = this.reduceRolls(keepMappedRolls.map(oneResult), dr.reducer);
            return diceReduceResult(diceMapeableResult(mapped, dr.reduceable.functor), dr.reducer, result);
        }
        else {
            throw new Error(`Unknown DiceReduce: ${JSON.stringify(dr)}`);
        }
    }
    roll(expr) {
        if (expr.type === 'die') {
            return oneResult(dieResult(this.dieRoll(expr.sides), expr.sides));
        }
        else if (expr.type === 'literal') {
            return literalResult(expr.value, expr.value);
        }
        else if (expr.type === 'dice-reduce') {
            return this.rollDiceReduce(expr);
        }
        else if (expr.type === 'binary-op') {
            const left = this.roll(expr.left);
            const right = this.roll(expr.right);
            if (expr.op === DiceBinOp.Sum) {
                return binaryOpResult(DiceBinOp.Sum, left, right, RR.getResult(left) + RR.getResult(right));
            }
            else if (expr.op === DiceBinOp.Difference) {
                return binaryOpResult(DiceBinOp.Difference, left, right, RR.getResult(left) - RR.getResult(right));
            }
            else if (expr.op === DiceBinOp.Multiplication) {
                return binaryOpResult(DiceBinOp.Multiplication, left, right, RR.getResult(left) * RR.getResult(right));
            }
            else if (expr.op === DiceBinOp.Division) {
                return binaryOpResult(DiceBinOp.Division, left, right, Math.trunc(RR.getResult(left) / RR.getResult(right)));
            }
            else {
                throw new Error(`Invalid binary operation ${JSON.stringify(expr)}`);
            }
        }
        else if (expr.type === 'unary-op') {
            const inner = this.roll(expr.expr);
            if (expr.op === DiceUnOp.Negate) {
                return unaryOpResult(DiceUnOp.Negate, inner, -RR.getResult(inner));
            }
            else {
                throw new Error(`Invalid unary operation ${JSON.stringify(expr)}`);
            }
        }
        else {
            throw new Error(`Invalid expressions ${JSON.stringify(expr)}`);
        }
    }
    mapRolls(rolls, functor) {
        const times = functor.times;
        switch (functor.type) {
            case 'explode':
                if (times.type === 'always') {
                    return rolls.map(roll => this.explodeRoll(roll, -1, functor.range));
                }
                else {
                    return rolls.map(roll => this.explodeRoll(roll, times.value, functor.range));
                }
            case 'reroll':
                if (times.type === 'always') {
                    return rolls.map(roll => this.rerollRoll(roll, -1, functor.range));
                }
                else {
                    return rolls.map(roll => this.rerollRoll(roll, times.value, functor.range));
                }
        }
    }
    explodeRoll(roll, times, range) {
        const acc = this.rollRange(roll, times, range);
        return acc.length === 1 ? normal(acc[0]) : exploded(acc);
    }
    rerollRoll(roll, times, range) {
        const acc = this.rollRange(roll, times, range);
        return acc.length === 1 ? normal(acc[0]) : rerolled(acc);
    }
    rollRange(roll, times, range) {
        const acc = [roll];
        let curr = roll;
        while (times !== 0 && Roller.matchRange(curr.result, range)) {
            curr = dieResult(this.dieRoll(curr.sides), curr.sides);
            acc.push(curr);
            times--;
        }
        return acc;
    }
    keepMappedRolls(rolls) {
        return rolls.flatMap(roll => {
            switch (roll.type) {
                case 'normal': return [roll.roll];
                case 'rerolled': return [roll.rerolls[roll.rerolls.length - 1]];
                case 'exploded': return roll.explosions;
                default: throw new Error(`Invalid mapped roll ${JSON.stringify(roll)}`);
            }
        });
    }
    filterRolls(rolls, filter) {
        const ranked = rank(rolls, (a, b) => {
            return compareNumbers(RR.getResult(a), RR.getResult(b));
        });
        const f = Roller.filterf(filter);
        return rolls.map((roll, i) => {
            if (f(ranked[i], ranked.length)) {
                return keepResult(roll);
            }
            else {
                return discardResult(roll);
            }
        });
    }
    keepFilteredRolls(rolls) {
        return mapNotNull(rolls, (roll) => {
            if (roll.type === 'keep-result') {
                return roll.roll;
            }
            else {
                return null;
            }
        });
    }
    reduceRolls(rolls, reducer) {
        return this.reduceResults(this.getRollResults(rolls), reducer);
    }
    reduceResults(results, reducer) {
        switch (reducer) {
            case DiceReducer.Average: return Math.round(results.reduce((a, b) => a + b, 0) / results.length);
            case DiceReducer.Median: return median(results);
            case DiceReducer.Sum: return results.reduce((a, b) => a + b, 0);
            case DiceReducer.Min: return Math.min(...results);
            case DiceReducer.Max: return Math.max(...results);
        }
    }
    getRollResults(rolls) {
        return rolls.map(RR.getResult);
    }
}
