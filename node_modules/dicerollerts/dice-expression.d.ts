export type Sides = number;
export type Roll = (sides: Sides) => number;
export interface Die {
    type: 'die';
    sides: number;
}
export declare function die(sides: number): Die;
export interface Literal {
    type: 'literal';
    value: number;
}
export declare function literal(value: number): Literal;
export interface DiceReduce {
    type: 'dice-reduce';
    reduceable: DiceReduceable;
    reducer: DiceReducer;
}
export declare function diceReduce(reduceable: DiceReduceable, reducer: DiceReducer): DiceReduce;
export interface BinaryOp {
    type: 'binary-op';
    op: DiceBinOp;
    left: DiceExpression;
    right: DiceExpression;
}
export declare function binaryOp(op: DiceBinOp, left: DiceExpression, right: DiceExpression): BinaryOp;
export interface UnaryOp {
    type: 'unary-op';
    op: DiceUnOp;
    expr: DiceExpression;
}
export declare function unaryOp(op: DiceUnOp, expr: DiceExpression): UnaryOp;
export type DiceExpression = Die | Literal | DiceReduce | BinaryOp | UnaryOp;
export declare enum DiceReducer {
    Sum = "sum",
    Min = "min",
    Max = "max",
    Average = "average",
    Median = "median"
}
export interface DiceExpressions {
    type: 'dice-expressions';
    exprs: DiceExpression[];
}
export declare function diceExpressions(...exprs: DiceExpression[]): DiceExpressions;
export interface DiceListWithFilter {
    type: 'dice-list-with-filter';
    list: DiceFilterable;
    filter: DiceFilter;
}
export declare function diceListWithFilter(list: DiceFilterable, filter: DiceFilter): DiceListWithFilter;
export interface DiceListWithMap {
    type: 'dice-list-with-map';
    dice: Sides[];
    functor: DiceFunctor;
}
export declare function diceListWithMap(dice: Sides[], functor: DiceFunctor): DiceListWithMap;
export type DiceReduceable = DiceExpressions | DiceListWithFilter | DiceListWithMap;
export interface FilterableDiceArray {
    type: 'filterable-dice-array';
    dice: Sides[];
}
export declare function filterableDiceArray(dice: Sides[]): FilterableDiceArray;
export interface FilterableDiceExpressions {
    type: 'filterable-dice-expressions';
    exprs: DiceExpression[];
}
export declare function filterableDiceExpressions(...exprs: DiceExpression[]): FilterableDiceExpressions;
export type DiceFilterable = FilterableDiceArray | FilterableDiceExpressions;
export interface Drop {
    type: 'drop';
    dir: LowHigh;
    value: number;
}
export declare function drop(dir: LowHigh, value: number): Drop;
export interface Keep {
    type: 'keep';
    dir: LowHigh;
    value: number;
}
export declare function keep(dir: LowHigh, value: number): Keep;
export type DiceFilter = Drop | Keep;
export interface Explode {
    type: 'explode';
    times: Times;
    range: Range;
}
export declare function explode(times: Times, range: Range): Explode;
export interface Reroll {
    type: 'reroll';
    times: Times;
    range: Range;
}
export declare function reroll(times: Times, range: Range): Reroll;
export type DiceFunctor = Explode | Reroll;
export interface Always {
    type: 'always';
}
export declare function always(): Always;
export interface UpTo {
    type: 'up-to';
    value: number;
}
export declare function upTo(value: number): UpTo;
export type Times = Always | UpTo;
export interface Exact {
    type: 'exact';
    value: number;
}
export declare function exact(value: number): Exact;
export interface Between {
    type: 'between';
    minInclusive: number;
    maxInclusive: number;
}
export declare function between(minInclusive: number, maxInclusive: number): Between;
export interface ValueOrMore {
    type: 'value-or-more';
    value: number;
}
export declare function valueOrMore(value: number): ValueOrMore;
export interface ValueOrLess {
    type: 'value-or-less';
    value: number;
}
export declare function valueOrLess(value: number): ValueOrLess;
export interface Composite {
    type: 'composite';
    ranges: Range[];
}
export declare function composite(ranges: Range[]): Composite;
export type Range = Exact | Between | ValueOrMore | ValueOrLess | Composite;
export declare enum LowHigh {
    Low = "low",
    High = "high"
}
export declare enum DiceBinOp {
    Sum = "sum",
    Difference = "difference",
    Multiplication = "multiplication",
    Division = "division"
}
export declare enum DiceUnOp {
    Negate = "negate"
}
export interface InsufficientSides {
    type: 'insufficient-sides';
    sides: number;
}
export declare function insufficientSides(sides: number): InsufficientSides;
export interface EmptySet {
    type: 'empty-set';
}
export declare function emptySet(): EmptySet;
export interface InfiniteReroll {
    type: 'infinite-reroll';
    sides: number;
    range: Range;
}
export declare function infiniteReroll(sides: number, range: Range): InfiniteReroll;
export interface TooManyDrops {
    type: 'too-many-drops';
    available: number;
    toDrop: number;
}
export declare function tooManyDrops(available: number, toDrop: number): TooManyDrops;
export interface TooManyKeeps {
    type: 'too-many-keeps';
    available: number;
    toKeep: number;
}
export declare function tooManyKeeps(available: number, toKeep: number): TooManyKeeps;
export interface DropOrKeepShouldBePositive {
    type: 'drop-or-keep-should-be-positive';
}
export declare function dropOrKeepShouldBePositive(): DropOrKeepShouldBePositive;
export type ValidationMessage = InsufficientSides | EmptySet | InfiniteReroll | TooManyDrops | TooManyKeeps | DropOrKeepShouldBePositive;
