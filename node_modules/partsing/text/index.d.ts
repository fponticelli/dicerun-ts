/**
 * This module contains a set of decoders and utility functions to decode
 * string values.
 */
import { Decoder } from '../core/decoder';
import { DecodeFailure, DecodeResult } from '../core/result';
import { DecodeError } from '../error';
/**
 * `TextInput` stores the entire `input` value as a `string` and contains
 * an `index` as the current character position inside the stream.
 */
export interface TextInput {
    /**
     * The string input. Its value is never modified by the decoders at any point
     * in the chain.
     */
    readonly input: string;
    /**
     * The current position reached by a decoder.
     */
    readonly index: number;
}
/**
 * Type alias for a decoder specialized in consuming values of type `{@link TextInput}`
 * and generate errors of type `{@link DecodeError}`.
 */
export declare type TextDecoder<T> = Decoder<TextInput, T, DecodeError>;
/**
 * Helper function that return a function to decode from an `input` of type `string` to a `DecodeResult`.
 *
 * The function takes a `TextDecoder` as the only argument.
 *
 * This convenience function exists because `TextDecoder` requires an input of
 * type {@link TextInput} and not `string`.
 */
export declare const decodeText: <T>(decoder: Decoder<TextInput, T, DecodeError>) => (input: string) => DecodeResult<string, T, string>;
/**
 * Generate a `TextDecoder` that uses a `RegExp` pattern to match a result.
 *
 * By default, this decoder will capture the first group (group 0) returned from
 * the regular expression. This can be changed by providing a different value to
 * `group`.
 *
 * If the JS runtime you are working with allows it, it is suggested to use the
 * **stycky** modifier `y`. Its main advantage is that it doesn't need to reallocate
 * a substring of the original input to perform its matching.
 */
export declare const regexp: (pattern: RegExp, group?: number) => Decoder<TextInput, string, DecodeError>;
/**
 * A decoder that doesn't consume any portion of the string but does
 * return the current index position as its result value.
 */
export declare const withPosition: Decoder<TextInput, number, DecodeError>;
/**
 * A decoder that produces all the remaining characters in `TextInput`.
 */
export declare const rest: Decoder<TextInput, string, DecodeError>;
/**
 * A decoder that doesn't consume anything from the `TextInput` and produces
 * `undefined` if it matches the end of the input.
 */
export declare const eoi: Decoder<TextInput, void, DecodeError>;
/**
 * Create a decoder that consume and produces an exact string match.
 */
export declare const match: <V extends string>(s: V) => Decoder<TextInput, V, DecodeError>;
/**
 * Same as {@link match} but case-insensitive.
 */
export declare const matchInsensitive: (s: string) => Decoder<TextInput, string, DecodeError>;
/**
 * Match exactly one char given its char code value as a `number`.
 */
export declare const matchCharCode: (charCode: number) => Decoder<TextInput, string, DecodeError>;
/**
 * Match exactly one char given its char code value as a `number`.
 */
export declare const matchChar: (char: string) => Decoder<TextInput, string, DecodeError>;
/**
 * Match any single char from a list of possible values `anyOf`.
 */
export declare const matchAnyCharOf: (anyOf: string) => Decoder<TextInput, string, DecodeError>;
/**
 * Match any single char that is not included in the list of possible values `noneOf`.
 */
export declare const matchNoCharOf: (noneOf: string) => Decoder<TextInput, string, DecodeError>;
/**
 * Match any alphabetical character in a case insensitive matter.
 */
export declare const letter: Decoder<TextInput, string, DecodeError>;
/**
 * Match a sequence of case-insensitve alphabetical characters. It expects at
 * least one occurance. The boundaries `min` and `max` are both inclusive and
 * optional.
 */
export declare const letters: (min?: number, max?: number | undefined) => Decoder<TextInput, string, DecodeError>;
/**
 * Match any alphabetical upper-case-character.
 */
export declare const upperCaseLetter: Decoder<TextInput, string, DecodeError>;
/**
 * Match a sequence of upper-case alphabetical characters. It expects at least
 * one occurance. The boundaries `min` and `max` are both inclusive and optional.
 */
export declare const upperCaseLetters: (min?: number, max?: number | undefined) => Decoder<TextInput, string, DecodeError>;
/**
 * Match any alphabetical lower-ccase-character.
 */
export declare const lowerCaseLetter: Decoder<TextInput, string, DecodeError>;
/**
 * Match a sequence of lower-case alphabetical characters. It expects at least
 * one occurance. The boundaries `min` and `max` are both inclusive and optional.
 */
export declare const lowerCaseLetters: (min?: number, max?: number | undefined) => Decoder<TextInput, string, DecodeError>;
/**
 * Match a single digit character.
 */
export declare const digit: Decoder<TextInput, string, DecodeError>;
/**
 * Match a sequence of digit characters. It expects at least one occurance.
 * The boundaries `min` and `max` are both inclusive and optional.
 */
export declare const digits: (min?: number, max?: number | undefined) => Decoder<TextInput, string, DecodeError>;
/**
 * Match a single whitespace character.
 */
export declare const whitespace: Decoder<TextInput, string, DecodeError>;
/**
 * Match an optional whitespace character. If no whitespace is matched, the result
 * is the empty string `""`.
 */
export declare const optionalWhitespace: Decoder<TextInput, string, DecodeError>;
/**
 * Decoder that matches one single character. This decoder will only fail if it
 * encounters the `EOI` (end of input).
 */
export declare const char: Decoder<TextInput, unknown, DecodeError>;
/**
 * Produces a decoder similar to {@link char} but the char is tested through
 * the predicate function `f`. The character value is produced only if the predicate
 * succeeds.
 */
export declare const testChar: (f: (c: string) => boolean) => Decoder<TextInput, string, DecodeError>;
/**
 * Take a sequence of char that all satisfy the predicate `f`. It works much like
 * {@link testChar} but for a sequence of charecters. The default is that the
 * decoder should match at least one result. That can be changed by passing
 * the second optional argument `atLeast` with a different value.
 */
export declare const takeCharWhile: (f: (c: string) => boolean, atLeast?: number) => Decoder<TextInput, string, DecodeError>;
/**
 * Same as {@link takeCharWhile} but with a minimum (`min`) and maximum (`max`)
 * constraints. They are both inclusive and mandatory.
 */
export declare const takeCharBetween: (f: (c: string) => boolean, min: number, max: number) => Decoder<TextInput, string, DecodeError>;
/**
 * Pretty prints a `DecodeFailure<TextInput, Out, DecodeError>`.
 */
export declare const failureToString: <Out>(err: DecodeFailure<TextInput, Out, DecodeError>) => string;
