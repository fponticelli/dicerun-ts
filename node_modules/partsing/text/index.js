"use strict";
/*
Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This module contains a set of decoders and utility functions to decode
 * string values.
 */
var decoder_1 = require("../core/decoder");
var result_1 = require("../core/result");
var error_1 = require("../error");
/**
 * Utility function to generate a decoder of type `{@link ValueDecoder}` from a function `f`.
 */
var make = function (f) { return decoder_1.Decoder.of(f); };
/**
 * Helper function that return a function to decode from an `input` of type `string` to a `DecodeResult`.
 *
 * The function takes a `TextDecoder` as the only argument.
 *
 * This convenience function exists because `TextDecoder` requires an input of
 * type {@link TextInput} and not `string`.
 */
exports.decodeText = function (decoder) { return function (input) {
    return decoder.run({ input: input, index: 0 }).match({
        success: function (r) { return result_1.success(input, r.value); },
        failure: function (f) { return result_1.failure(input, exports.failureToString(f)); }
    });
}; };
/**
 * Generate a `TextDecoder` that uses a `RegExp` pattern to match a result.
 *
 * By default, this decoder will capture the first group (group 0) returned from
 * the regular expression. This can be changed by providing a different value to
 * `group`.
 *
 * If the JS runtime you are working with allows it, it is suggested to use the
 * **stycky** modifier `y`. Its main advantage is that it doesn't need to reallocate
 * a substring of the original input to perform its matching.
 */
exports.regexp = function (pattern, group) {
    if (group === void 0) { group = 0; }
    if (pattern.sticky) {
        return make(function (input) {
            pattern.lastIndex = input.index;
            var res = pattern.exec(input.input);
            if (res == null) {
                return result_1.failure(input, error_1.DecodeError.patternMismatch(pattern.source));
            }
            else {
                return result_1.success(__assign({}, input, { index: pattern.lastIndex }), res[group]);
            }
        });
    }
    else if (pattern.global) {
        return make(function (input) {
            var s = input.input.substring(input.index);
            pattern.lastIndex = 0;
            var res = pattern.exec(s);
            if (res == null) {
                return result_1.failure(input, error_1.DecodeError.patternMismatch(pattern.source));
            }
            else {
                var index = input.index + pattern.lastIndex;
                return result_1.success(__assign({}, input, { index: index }), res[group]);
            }
        });
    }
    else {
        return make(function (input) {
            var s = input.input.substring(input.index);
            pattern.lastIndex = 0;
            var res = pattern.exec(s);
            if (res == null) {
                return result_1.failure(input, error_1.DecodeError.patternMismatch(pattern.source));
            }
            else {
                var index = input.index + s.indexOf(res[0]) + res[0].length;
                return result_1.success(__assign({}, input, { index: index }), res[group]);
            }
        });
    }
};
/**
 * A decoder that doesn't consume any portion of the string but does
 * return the current index position as its result value.
 */
exports.withPosition = make(function (input) { return result_1.success(input, input.index); });
/**
 * A decoder that produces all the remaining characters in `TextInput`.
 */
exports.rest = make(function (input) {
    var value = input.input.substring(input.index);
    return result_1.success(__assign({}, input, { index: input.input.length }), value);
});
/**
 * A decoder that doesn't consume anything from the `TextInput` and produces
 * `undefined` if it matches the end of the input.
 */
exports.eoi = make(function (input) {
    var index = input.input.length;
    if (input.index === index) {
        return result_1.success(__assign({}, input, { index: index }), undefined);
    }
    else {
        return result_1.failure(input, error_1.DecodeError.expectedEoi);
    }
});
/**
 * Create a decoder that consume and produces an exact string match.
 */
exports.match = function (s) {
    var length = s.length;
    return make(function (input) {
        var index = input.index + length;
        var value = input.input.substring(input.index, index);
        if (value === s) {
            return result_1.success(__assign({}, input, { index: index }), s);
        }
        else {
            return result_1.failure(input, error_1.DecodeError.expectedMatch(error_1.Entity.STRING, "\"" + s + "\""));
        }
    });
};
/**
 * Same as {@link match} but case-insensitive.
 */
exports.matchInsensitive = function (s) {
    var t = s.toLowerCase();
    var length = s.length;
    return make(function (input) {
        var index = input.index + length;
        var value = input.input.substring(input.index, index);
        var valueInsensitive = value.toLowerCase();
        if (valueInsensitive === t) {
            return result_1.success(__assign({}, input, { index: index }), value);
        }
        else {
            return result_1.failure(input, error_1.DecodeError.expectedMatch(error_1.Entity.STRING_INSENSITIVE, "\"" + s + "\""));
        }
    });
};
/**
 * Match exactly one char given its char code value as a `number`.
 */
exports.matchCharCode = function (charCode) {
    var char = String.fromCharCode(charCode);
    return make(function (input) {
        if (input.input.charCodeAt(input.index) === charCode) {
            return result_1.success(__assign({}, input, { index: input.index + char.length }), char);
        }
        else {
            return result_1.failure(input, error_1.DecodeError.expectedMatch(error_1.Entity.CHARACTER_CODE, "" + charCode));
        }
    });
};
/**
 * Match exactly one char given its char code value as a `number`.
 */
exports.matchChar = function (char) {
    var charCode = char.charCodeAt(0);
    return make(function (input) {
        if (input.input.charCodeAt(input.index) === charCode) {
            return result_1.success(__assign({}, input, { index: input.index + char.length }), char);
        }
        else {
            return result_1.failure(input, error_1.DecodeError.expectedMatch(error_1.Entity.CHARACTER, char));
        }
    });
};
/**
 * Match any single char from a list of possible values `anyOf`.
 */
exports.matchAnyCharOf = function (anyOf) {
    return exports.testChar(function (c) { return anyOf.indexOf(c) >= 0; }).withFailure(error_1.DecodeError.expectedAnyOf(error_1.Entity.CHARACTER, anyOf.split('').map(function (v) { return "\"" + v + "\""; })));
};
/**
 * Match any single char that is not included in the list of possible values `noneOf`.
 */
exports.matchNoCharOf = function (noneOf) {
    return exports.testChar(function (c) { return noneOf.indexOf(c) < 0; }).withFailure(error_1.DecodeError.expectedNoneOf(error_1.Entity.CHARACTER, noneOf.split('').map(function (v) { return "\"" + v + "\""; })));
};
/**
 * Helper patterns used in exposed functions.
 */
var _a = (function () {
    var testSticky = (function () {
        try {
            return /test/y.sticky;
        }
        catch (_) {
            return false;
        }
    })();
    if (testSticky) {
        return {
            letterPattern: /[a-z]/iy,
            lettersPattern: function (min, max) { return new RegExp("[a-z]{" + min + "," + max + "}", 'yi'); },
            upperCaseLetterPattern: /[A-Z]/y,
            upperCaseLettersPattern: function (min, max) { return new RegExp("[A-Z]{" + min + "," + max + "}", 'y'); },
            lowerCaseLetterPattern: /[a-z]/y,
            lowerCaseLettersPattern: function (min, max) { return new RegExp("[a-z]{" + min + "," + max + "}", 'y'); },
            digitPattern: /\d/y,
            digitsPattern: function (min, max) { return new RegExp("[0-9]{" + min + "," + max + "}", 'yi'); },
            whitespacePattern: /\s+/y,
            optionalWhitespacePattern: /\s*/y
        };
    }
    else {
        return {
            letterPattern: /^[a-z]/i,
            lettersPattern: function (min, max) { return new RegExp("^[a-z]{" + min + "," + max + "}", 'i'); },
            upperCaseLetterPattern: /^[A-Z]/,
            upperCaseLettersPattern: function (min, max) { return new RegExp("^[A-Z]{" + min + "," + max + "}", ''); },
            lowerCaseLetterPattern: /^[a-z]/,
            lowerCaseLettersPattern: function (min, max) { return new RegExp("^[a-z]{" + min + "," + max + "}", ''); },
            digitPattern: /^\d/,
            digitsPattern: function (min, max) { return new RegExp("^[0-9]{" + min + "," + max + "}", 'i'); },
            whitespacePattern: /^\s+/,
            optionalWhitespacePattern: /^\s*/
        };
    }
})(), letterPattern = _a.letterPattern, lettersPattern = _a.lettersPattern, upperCaseLetterPattern = _a.upperCaseLetterPattern, upperCaseLettersPattern = _a.upperCaseLettersPattern, lowerCaseLetterPattern = _a.lowerCaseLetterPattern, lowerCaseLettersPattern = _a.lowerCaseLettersPattern, digitPattern = _a.digitPattern, digitsPattern = _a.digitsPattern, whitespacePattern = _a.whitespacePattern, optionalWhitespacePattern = _a.optionalWhitespacePattern;
/**
 * Match any alphabetical character in a case insensitive matter.
 */
exports.letter = exports.regexp(letterPattern).withFailure(error_1.DecodeError.expectedOnce(error_1.Entity.LETTER));
/**
 * Match a sequence of case-insensitve alphabetical characters. It expects at
 * least one occurance. The boundaries `min` and `max` are both inclusive and
 * optional.
 */
exports.letters = function (min, max) {
    if (min === void 0) { min = 1; }
    var message = error_1.DecodeError.expectedAtLeast(min, error_1.Entity.LETTER);
    var maxs = max === undefined ? '' : String(max);
    return exports.regexp(lettersPattern(String(min), maxs)).withFailure(message);
};
/**
 * Match any alphabetical upper-case-character.
 */
exports.upperCaseLetter = exports.regexp(upperCaseLetterPattern).withFailure(error_1.DecodeError.expectedOnce(error_1.Entity.UPPERCASE_LETTER));
/**
 * Match a sequence of upper-case alphabetical characters. It expects at least
 * one occurance. The boundaries `min` and `max` are both inclusive and optional.
 */
exports.upperCaseLetters = function (min, max) {
    if (min === void 0) { min = 1; }
    var message = error_1.DecodeError.expectedAtLeast(min, error_1.Entity.UPPERCASE_LETTER);
    var maxs = max === undefined ? '' : String(max);
    return exports.regexp(upperCaseLettersPattern(String(min), maxs)).withFailure(message);
};
/**
 * Match any alphabetical lower-ccase-character.
 */
exports.lowerCaseLetter = exports.regexp(lowerCaseLetterPattern).withFailure(error_1.DecodeError.expectedOnce(error_1.Entity.LOWER_CASE_LETTER));
/**
 * Match a sequence of lower-case alphabetical characters. It expects at least
 * one occurance. The boundaries `min` and `max` are both inclusive and optional.
 */
exports.lowerCaseLetters = function (min, max) {
    if (min === void 0) { min = 1; }
    var message = error_1.DecodeError.expectedAtLeast(min, error_1.Entity.LOWER_CASE_LETTER);
    var maxs = max === undefined ? '' : String(max);
    return exports.regexp(lowerCaseLettersPattern(String(min), maxs)).withFailure(message);
};
/**
 * Match a single digit character.
 */
exports.digit = exports.regexp(digitPattern).withFailure(error_1.DecodeError.expectedOnce(error_1.Entity.DIGIT));
/**
 * Match a sequence of digit characters. It expects at least one occurance.
 * The boundaries `min` and `max` are both inclusive and optional.
 */
exports.digits = function (min, max) {
    if (min === void 0) { min = 1; }
    var message = error_1.DecodeError.expectedAtLeast(min, error_1.Entity.DIGIT);
    var maxs = max === undefined ? '' : String(max);
    return exports.regexp(digitsPattern(String(min), maxs)).withFailure(message);
};
/**
 * Match a single whitespace character.
 */
exports.whitespace = exports.regexp(whitespacePattern).withFailure(error_1.DecodeError.expectedAtLeast(1, error_1.Entity.WHITESPACE));
/**
 * Match an optional whitespace character. If no whitespace is matched, the result
 * is the empty string `""`.
 */
exports.optionalWhitespace = exports.regexp(optionalWhitespacePattern);
/**
 * Decoder that matches one single character. This decoder will only fail if it
 * encounters the `EOI` (end of input).
 */
exports.char = make(function (input) {
    if (input.index < input.input.length) {
        var c = input.input.charAt(input.index);
        return result_1.success(__assign({}, input, { index: input.index + 1 }), c);
    }
    else {
        // no more characters
        return result_1.failure(input, error_1.DecodeError.expectedOnce(error_1.Entity.CHARACTER));
    }
});
/**
 * Produces a decoder similar to {@link char} but the char is tested through
 * the predicate function `f`. The character value is produced only if the predicate
 * succeeds.
 */
exports.testChar = function (f) {
    return make(function (input) {
        if (input.index >= input.input.length) {
            return result_1.failure(input, error_1.DecodeError.unexpectedEoi);
        }
        else {
            var char_1 = input.input.charAt(input.index);
            if (f(char_1)) {
                return result_1.success(__assign({}, input, { index: input.index + 1 }), char_1);
            }
            else {
                return result_1.failure(input, error_1.DecodeError.expectedOnce(error_1.Entity.PREDICATE));
            }
        }
    });
};
/**
 * Take a sequence of char that all satisfy the predicate `f`. It works much like
 * {@link testChar} but for a sequence of charecters. The default is that the
 * decoder should match at least one result. That can be changed by passing
 * the second optional argument `atLeast` with a different value.
 */
exports.takeCharWhile = function (f, atLeast) {
    if (atLeast === void 0) { atLeast = 1; }
    return make(function (input) {
        var index = input.index;
        while (index < input.input.length && f(input.input.charAt(index))) {
            index++;
        }
        if (index - input.index < atLeast) {
            return result_1.failure(input, error_1.DecodeError.expectedAtLeast(atLeast, error_1.Entity.PREDICATE));
        }
        else {
            return result_1.success(__assign({}, input, { index: index }), input.input.substring(input.index, index));
        }
    });
};
/**
 * Same as {@link takeCharWhile} but with a minimum (`min`) and maximum (`max`)
 * constraints. They are both inclusive and mandatory.
 */
exports.takeCharBetween = function (f, min, max) {
    return make(function (input) {
        var index = input.index;
        var counter = 0;
        while (index < input.input.length && counter < max && f(input.input.charAt(index))) {
            index++;
            counter++;
        }
        if (counter < min) {
            return result_1.failure(input, error_1.DecodeError.expectedAtLeast(min, error_1.Entity.PREDICATE));
        }
        else {
            return result_1.success(__assign({}, input, { index: index }), input.input.substring(input.index, index));
        }
    });
};
/**
 * Pretty prints a `DecodeFailure<TextInput, Out, DecodeError>`.
 */
exports.failureToString = function (err) {
    var failures = err.failures, input = err.input;
    var msg = failures.length === 1 ? failures[0].toString() : "one of:\n * " + failures.map(function (v) { return v.toString(); }).join('\n * ') + "\n";
    var length = Math.min(25, Math.max(msg.length, 10), input.input.length - input.index);
    var prefix = input.index === 0 ? '' : '…';
    var suffix = input.index < input.input.length - 1 ? '…' : '';
    var extract = input.input.substr(input.index, length);
    return "expected " + msg + " at \"" + prefix + extract + suffix + "\"";
};
//# sourceMappingURL=index.js.map