import { DecodeResult } from './result';
import { TupleToUnion } from './type_level';
/**
 * Type signature for a function that takes an input and decodes it into a
 * result object.
 */
export declare type Decoding<In, Out, Err> = (input: In) => DecodeResult<In, Out, Err>;
/**
 * The Decoder class is the base type to implement custom decoders.
 * It has three type parameters:
 *
 * * `In` for input. The input to a decoder can be any raw value that your decoder
 * can extract information from. In a simple case it could be a `string` value
 * or an array of bytes. If decoders are chained, the input needs to be
 * transferred from one decoder to the following one. That is why
 * {@link DecodeResult} has an `Input` as well. It is important to notice that
 * what is passed to the next decoder needs to be the relative input and not the
 * original one. For efficiency reasons, most decoders will wrap their own input
 * into some more sophisticated type to allow tracking the current position in
 * the stream.
 *
 * * `Out` for output. It's the type of the value return by the decoder if it
 * succeeds. Through operations like {@link Decoder.map} and
 * {@link Decoder.flatMap}, this type can be changed.
 *
 * * `Err` for error. It's the type of the error message. In some
 * implementations it might be as simple as `string`. For the embedded decoders
 * (text and value), the error is fixed to the
 * {@link DecodeError} unione type.
 * The constructors for {@link DecodeError} have more semantic value than
 * strings and can be properly used for localization.
 */
export declare class Decoder<In, Out, Err> {
    readonly run: Decoding<In, Out, Err>;
    /**
     * Creates a decoder from a [Decoding] function.
     */
    static of<In, Out, Err>(run: Decoding<In, Out, Err>): Decoder<In, Out, Err>;
    /**
     * These placeholder (`_I`, `_O`, `_E`) types are not expected to bring any
     * value. They exist to allow inspecting the main types of a Decoder at
     * compile time.
     */
    readonly _E: Err;
    /**
     * See {@link _E}.
     */
    readonly _I: In;
    /**
     * See {@link _E}.
     */
    readonly _O: Out;
    /**
     * Construct an instance of `Decoder` using the passed `run` function to
     * perform the decoding.
     */
    private constructor();
    /**
     * `flatMap` allows to combine the result of a decoder with a new one.
     *
     * It can be used to conditionally pick the next decoder in a chain based
     * on the result of a previous step.
     */
    flatMap<Out2>(fun: (res: Out) => Decoder<In, Out2, Err>): Decoder<In, Out2, Err>;
    /**
     * Convert and/or transform the result of a decoding into a different value.
     *
     * The applied function argument is executed exclusively on a succesful result
     * of decoding.
     *
     * *example*
     * ```ts
     * regexp(/\d{4}-\d{2}-\d{2}/y).map(Date.parse)
     * ```
     */
    map<Out2>(fun: (res: Out) => Out2): Decoder<In, Out2, Err>;
    /**
     * Similar to {@link map} but passes a tuple of `res: Out` and `input: In`. This is mostly useful when decoding
     * tokens to preserve the original position in the input.
     */
    mapWithInput<Out2>(fun: (res: Out, input: In) => Out2): Decoder<In, Out2, Err>;
    /**
     * Allow to convert the result of decoder into the input for another one. It
     * can be used to use different kind of decoders together.
     */
    sub<In2, Out2, Err2>(decoder: Decoder<In2, Out2, Err2>, mapInput: (o: Out) => In2, mapError: (e: Err2) => Err): Decoder<In, Out2, Err>;
    /**
     * Like {@link flatMap} but for the failure case. It is also useful to recover
     * from an error.
     */
    flatMapError<Err2>(fun: (res: Err[]) => Decoder<In, Out, Err2>): Decoder<In, Out, Err2>;
    /**
     * Like {@link map} but for the failure case.
     */
    mapError<Err2>(fun: (e: Err) => Err2): Decoder<In, Out, Err2>;
    /**
     * On a successful decoding of the current decoder, it moves to the `next` one
     * returning only its result.
     */
    pickNext<Out2>(next: Decoder<In, Out2, Err>): Decoder<In, Out2, Err>;
    /**
     * Make sure that the current decoder is followed by the one defined in `next`
     * but it ignores its result.
     */
    skipNext<Out2>(next: Decoder<In, Out2, Err>): Decoder<In, Out, Err>;
    /**
     * Combines the result of the current decoder with the one in next and returns
     * them as tuple of two if they are both successful.
     */
    join<Out2>(next: Decoder<In, Out2, Err>): Decoder<In, [Out, Out2], Err>;
    /**
     * If the current decoder fails, it tries the ones passed as arguments until
     * one of them succeeds or they all fail.
     */
    or<U extends any[]>(...decoders: {
        [P in keyof U]: Decoder<In, U[P], Err>;
    }): Decoder<In, Out | TupleToUnion<U>, Err>;
    /**
     * Expect the current decoder to be repeated at least n `times`.
     *
     * The result is an array of `Out` values.
     */
    atLeast(times: number): Decoder<In, Out[], Err>;
    /**
     * Repeat the current decoder zero or more times.
     */
    many(): Decoder<In, Out[], Err>;
    /**
     * Repeat the current decoder between `min` and `max` times.
     */
    between(min: number, max: number): Decoder<In, Out[], Err>;
    /**
     * Repeat the current decoder exactly n `times`.
     */
    repeat(times: number): Decoder<In, Out[], Err>;
    /**
     * Repeat the current decoder at most n `times`.
     *
     * Notice that this allows for zero successes. Which makes this decoder
     * optional.
     */
    atMost(times: number): Decoder<In, Out[], Err>;
    /**
     * Given a `separator` decoder, it returns an array of values from the current
     * decoder. It is expected that at least `times` values are returned from this
     * decoder.
     */
    atLeastWithSeparator<Separator>(times: number, separator: Decoder<In, Separator, Err>): Decoder<In, Out[], Err>;
    /**
     * Given a `separator` decoder, it returns an array of values from the current
     * decoder. It is expected that at most `times` values are returned from this
     * decoder.
     */
    atMostWithSeparator<Separator>(times: number, separator: Decoder<In, Separator, Err>): Decoder<In, Out[], Err>;
    /**
     * Given a `separator` decoder, it returns an array of values from the current
     * decoder. It is expected any number of values returned, even zero.
     */
    manyWithSeparator<Separator>(separator: Decoder<In, Separator, Err>): Decoder<In, Out[], Err>;
    /**
     * Given a `separator` decoder, it returns an array of values from the current
     * decoder. It is expected that exactly `times` values are returned from this
     * decoder.
     */
    repeatWithSeparator<Separator>(times: number, separator: Decoder<In, Separator, Err>): Decoder<In, Out[], Err>;
    /**
     * Given a `separator` decoder, it returns an array of values from the current
     * decoder. It is expected that between `min` and `max` values are returned.
     */
    betweenWithSeparator<Separator>(min: number, max: number, separator: Decoder<In, Separator, Err>): Decoder<In, Out[], Err>;
    /**
     * Put the current decoder between `before` and `after`. The values captured
     * by `before` and `after` are discarded.
     *
     * @param before opening decoder.
     * @param after optional closing decoder. If omitted `before` will be used.
     */
    surroundedBy(before: Decoder<In, any, Err>, after?: Decoder<In, any, Err>): Decoder<In, Out, Err>;
    /**
     * If the current decoder is successful it passes its value to `predicate`
     * and succeed the decoding if the function returns `true`.
     *
     * `failure` is provided to have an explicit error if `predicate` fails.
     */
    test(predicate: (r: Out) => boolean, err: Err): Decoder<In, Out, Err>;
    /**
     * The `probe` method is used to perform a side-effecty function somewhere in
     * the decoder chain. It is mostly used as a debugging mechanism.
     *
     *  *example*
     * ```ts
     * decoder.probe(console.log).map(v => ...)
     * ```
     */
    probe(f: (v: DecodeResult<In, Out, Err>) => void): Decoder<In, Out, Err>;
    /**
     * If the current decoder executes succesfully, ignore its result and
     * replace it with `value`.
     */
    withResult<Out2>(value: Out2): Decoder<In, Out2, Err>;
    /**
     * If the current decoder fails, replace its error with the value of `e`.
     */
    withFailure<Err2>(e: Err2): Decoder<In, Out, Err2>;
}
/**
 * Given an array of decoders it tries to apply them all in sequence.
 * If they all succeed it returns a typed `n` tuple where each element type
 * matches the expected type of the corresponding decoder.
 */
export declare const sequence: <U extends any[], D extends { [P in keyof U]: Decoder<D[P]["_I"], U[P], D[P]["_E"]>; }>(...decoders: D & { [P in keyof U]: Decoder<D[0]["_I"], U[P], D[0]["_E"]>; }) => Decoder<D[0]["_I"], { [P in keyof U]: U[P]; }, D[0]["_E"]>;
/**
 * Given an array of decoders, it traverses them all until one succeeds or they
 * all fail.
 */
export declare const oneOf: <U extends any[], D extends { [P in keyof U]: Decoder<D[P]["_I"], U[P], D[P]["_E"]>; }>(...decoders: D & { [P in keyof U]: Decoder<D[0]["_I"], U[P], D[0]["_E"]>; }) => Decoder<D[0]["_I"], U[number], D[0]["_E"]>;
/**
 * Returns a decoder that always succeeds with the given result. The decoder
 * doesn't consume anything from the input.
 */
export declare const succeed: <In, Out, Err>(result: Out) => Decoder<In, Out, Err>;
/**
 * Returns a decoder that always fails with the given error.
 */
export declare const fail: <In, Out, Err>(err: Err) => Decoder<In, Out, Err>;
/**
 * Often time decoders are defined recursively. The language and type-system
 * do not allow for recursion. To work around that limit you create a `lazy`
 * decoder that wraps the desired decoder into a lazy function.
 *
 * The decoder function `f` is only invoked once and its result is reused
 * mutliple times if needed.
 */
export declare const lazy: <In, Out, Err>(f: () => Decoder<In, Out, Err>) => Decoder<In, Out, Err>;
