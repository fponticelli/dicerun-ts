"use strict";
/*
Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
var result_1 = require("./result");
/**
 * The Decoder class is the base type to implement custom decoders.
 * It has three type parameters:
 *
 * * `In` for input. The input to a decoder can be any raw value that your decoder
 * can extract information from. In a simple case it could be a `string` value
 * or an array of bytes. If decoders are chained, the input needs to be
 * transferred from one decoder to the following one. That is why
 * {@link DecodeResult} has an `Input` as well. It is important to notice that
 * what is passed to the next decoder needs to be the relative input and not the
 * original one. For efficiency reasons, most decoders will wrap their own input
 * into some more sophisticated type to allow tracking the current position in
 * the stream.
 *
 * * `Out` for output. It's the type of the value return by the decoder if it
 * succeeds. Through operations like {@link Decoder.map} and
 * {@link Decoder.flatMap}, this type can be changed.
 *
 * * `Err` for error. It's the type of the error message. In some
 * implementations it might be as simple as `string`. For the embedded decoders
 * (text and value), the error is fixed to the
 * {@link DecodeError} unione type.
 * The constructors for {@link DecodeError} have more semantic value than
 * strings and can be properly used for localization.
 */
var Decoder = /** @class */ (function () {
    /**
     * Construct an instance of `Decoder` using the passed `run` function to
     * perform the decoding.
     */
    function Decoder(run) {
        this.run = run;
    }
    /**
     * Creates a decoder from a [Decoding] function.
     */
    Decoder.of = function (run) {
        return new Decoder(run);
    };
    /**
     * `flatMap` allows to combine the result of a decoder with a new one.
     *
     * It can be used to conditionally pick the next decoder in a chain based
     * on the result of a previous step.
     */
    Decoder.prototype.flatMap = function (fun) {
        var _this = this;
        return Decoder.of(function (input) {
            var result = _this.run(input);
            if (result.isSuccess()) {
                return fun(result.value).run(result.input);
            }
            else {
                return result_1.failure.apply(void 0, [input].concat(result.failures));
            }
        });
    };
    /**
     * Convert and/or transform the result of a decoding into a different value.
     *
     * The applied function argument is executed exclusively on a succesful result
     * of decoding.
     *
     * *example*
     * ```ts
     * regexp(/\d{4}-\d{2}-\d{2}/y).map(Date.parse)
     * ```
     */
    Decoder.prototype.map = function (fun) {
        return this.flatMap(function (r) { return Decoder.of(function (input) { return result_1.success(input, fun(r)); }); });
    };
    /**
     * Similar to {@link map} but passes a tuple of `res: Out` and `input: In`. This is mostly useful when decoding
     * tokens to preserve the original position in the input.
     */
    Decoder.prototype.mapWithInput = function (fun) {
        var _this = this;
        return Decoder.of(function (input) {
            var result = _this.run(input);
            if (result.isSuccess()) {
                return result_1.success(result.input, fun(result.value, input));
            }
            else {
                return result_1.failure.apply(void 0, [input].concat(result.failures));
            }
        });
    };
    /**
     * Allow to convert the result of decoder into the input for another one. It
     * can be used to use different kind of decoders together.
     */
    Decoder.prototype.sub = function (decoder, mapInput, mapError) {
        var _this = this;
        return Decoder.of(function (input) {
            return _this.run(input).match({
                success: function (s) {
                    return decoder
                        .mapError(mapError)
                        .run(mapInput(s.value))
                        .mapInput(function (_) { return s.input; });
                },
                failure: function (f) { return result_1.failure.apply(void 0, [f.input].concat(f.failures)); }
            });
        });
    };
    /**
     * Like {@link flatMap} but for the failure case. It is also useful to recover
     * from an error.
     */
    Decoder.prototype.flatMapError = function (fun) {
        var _this = this;
        return Decoder.of(function (input) {
            return _this.run(input).match({
                failure: function (f) { return fun(f.failures).run(input); },
                success: function (s) { return result_1.success(s.input, s.value); }
            });
        });
    };
    /**
     * Like {@link map} but for the failure case.
     */
    Decoder.prototype.mapError = function (fun) {
        var _this = this;
        return Decoder.of(function (input) {
            return _this.run(input).match({
                failure: function (f) { return result_1.failure.apply(void 0, [f.input].concat(f.failures.map(fun))); },
                success: function (s) { return result_1.success(s.input, s.value); }
            });
        });
    };
    /**
     * On a successful decoding of the current decoder, it moves to the `next` one
     * returning only its result.
     */
    Decoder.prototype.pickNext = function (next) {
        return this.flatMap(function (_) { return next; });
    };
    /**
     * Make sure that the current decoder is followed by the one defined in `next`
     * but it ignores its result.
     */
    Decoder.prototype.skipNext = function (next) {
        return this.flatMap(function (r) { return next.withResult(r); });
    };
    /**
     * Combines the result of the current decoder with the one in next and returns
     * them as tuple of two if they are both successful.
     */
    Decoder.prototype.join = function (next) {
        return this.flatMap(function (res) { return next.map(function (o) { return [res, o]; }); });
    };
    /**
     * If the current decoder fails, it tries the ones passed as arguments until
     * one of them succeeds or they all fail.
     */
    Decoder.prototype.or = function () {
        var decoders = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            decoders[_i] = arguments[_i];
        }
        return this.flatMapError(function (errs) {
            return Decoder.of(function (input) {
                for (var _i = 0, decoders_1 = decoders; _i < decoders_1.length; _i++) {
                    var decoder = decoders_1[_i];
                    var result = decoder.run(input);
                    if (result.isFailure()) {
                        errs = errs.concat(result.failures);
                    }
                    else {
                        return result;
                    }
                }
                return result_1.failure.apply(void 0, [input].concat(errs));
            });
        });
    };
    /**
     * Expect the current decoder to be repeated at least n `times`.
     *
     * The result is an array of `Out` values.
     */
    Decoder.prototype.atLeast = function (times) {
        var _this = this;
        return Decoder.of(function (input) {
            var buff = [];
            while (true) {
                var result = _this.run(input);
                if (result.isSuccess()) {
                    buff.push(result.value);
                    input = result.input;
                }
                else if (buff.length < times) {
                    return result_1.failure.apply(void 0, [input].concat(result.failures));
                }
                else {
                    return result_1.success(input, buff);
                }
            }
        });
    };
    /**
     * Repeat the current decoder zero or more times.
     */
    Decoder.prototype.many = function () {
        return this.atLeast(0);
    };
    /**
     * Repeat the current decoder between `min` and `max` times.
     */
    Decoder.prototype.between = function (min, max) {
        var _this = this;
        return Decoder.of(function (input) {
            var buff = [];
            var failures = undefined;
            for (var i = 0; i < max; i++) {
                var result = _this.run(input);
                if (result.isSuccess()) {
                    buff.push(result.value);
                    input = result.input;
                }
                else {
                    failures = result.failures;
                    break;
                }
            }
            if (buff.length < min) {
                return result_1.failure.apply(void 0, [input].concat(failures));
            }
            else {
                return result_1.success(input, buff);
            }
        });
    };
    /**
     * Repeat the current decoder exactly n `times`.
     */
    Decoder.prototype.repeat = function (times) {
        return this.between(times, times);
    };
    /**
     * Repeat the current decoder at most n `times`.
     *
     * Notice that this allows for zero successes. Which makes this decoder
     * optional.
     */
    Decoder.prototype.atMost = function (times) {
        return this.between(0, times);
    };
    /**
     * Given a `separator` decoder, it returns an array of values from the current
     * decoder. It is expected that at least `times` values are returned from this
     * decoder.
     */
    Decoder.prototype.atLeastWithSeparator = function (times, separator) {
        return this.betweenWithSeparator(times, Infinity, separator);
    };
    /**
     * Given a `separator` decoder, it returns an array of values from the current
     * decoder. It is expected that at most `times` values are returned from this
     * decoder.
     */
    Decoder.prototype.atMostWithSeparator = function (times, separator) {
        return this.betweenWithSeparator(0, times, separator);
    };
    /**
     * Given a `separator` decoder, it returns an array of values from the current
     * decoder. It is expected any number of values returned, even zero.
     */
    Decoder.prototype.manyWithSeparator = function (separator) {
        return this.atLeastWithSeparator(0, separator);
    };
    /**
     * Given a `separator` decoder, it returns an array of values from the current
     * decoder. It is expected that exactly `times` values are returned from this
     * decoder.
     */
    Decoder.prototype.repeatWithSeparator = function (times, separator) {
        return this.betweenWithSeparator(times, times, separator);
    };
    /**
     * Given a `separator` decoder, it returns an array of values from the current
     * decoder. It is expected that between `min` and `max` values are returned.
     */
    Decoder.prototype.betweenWithSeparator = function (min, max, separator) {
        var _this = this;
        if (max < min) {
            var t = min;
            min = max;
            max = t;
        }
        if (max <= 0) {
            return exports.succeed([]);
        }
        var pair = separator.pickNext(this);
        var decoderF = function (value) {
            return Decoder.of(function (input) {
                var buff = [value];
                for (var i = 1; i < max; i++) {
                    var res = pair.run(input);
                    if (res.isFailure()) {
                        if (i >= min) {
                            return result_1.success(input, buff);
                        }
                        else {
                            return result_1.failure.apply(void 0, [input].concat(res.failures));
                        }
                    }
                    else {
                        buff.push(res.value);
                        input = res.input;
                    }
                }
                return result_1.success(input, buff);
            });
        };
        if (min <= 0) {
            return Decoder.of(function (input) {
                var res = _this.run(input);
                if (res.isSuccess()) {
                    return decoderF(res.value).run(res.input);
                }
                else {
                    return result_1.success(input, []);
                }
            });
        }
        else {
            return this.flatMap(decoderF);
        }
    };
    /**
     * Put the current decoder between `before` and `after`. The values captured
     * by `before` and `after` are discarded.
     *
     * @param before opening decoder.
     * @param after optional closing decoder. If omitted `before` will be used.
     */
    Decoder.prototype.surroundedBy = function (before, after) {
        if (!after)
            after = before;
        return before.pickNext(this).skipNext(after);
    };
    /**
     * If the current decoder is successful it passes its value to `predicate`
     * and succeed the decoding if the function returns `true`.
     *
     * `failure` is provided to have an explicit error if `predicate` fails.
     */
    Decoder.prototype.test = function (predicate, err) {
        return this.flatMap(function (res) {
            return Decoder.of(function (input) {
                if (predicate(res)) {
                    return result_1.success(input, res);
                }
                else {
                    return result_1.failure(input, err);
                }
            });
        });
    };
    /**
     * The `probe` method is used to perform a side-effecty function somewhere in
     * the decoder chain. It is mostly used as a debugging mechanism.
     *
     *  *example*
     * ```ts
     * decoder.probe(console.log).map(v => ...)
     * ```
     */
    Decoder.prototype.probe = function (f) {
        var _this = this;
        return Decoder.of(function (input) {
            var result = _this.run(input);
            f(result);
            return result;
        });
    };
    /**
     * If the current decoder executes succesfully, ignore its result and
     * replace it with `value`.
     */
    Decoder.prototype.withResult = function (value) {
        return this.map(function (_) { return value; });
    };
    /**
     * If the current decoder fails, replace its error with the value of `e`.
     */
    Decoder.prototype.withFailure = function (e) {
        return this.mapError(function (_) { return e; });
    };
    return Decoder;
}());
exports.Decoder = Decoder;
/**
 * Given an array of decoders it tries to apply them all in sequence.
 * If they all succeed it returns a typed `n` tuple where each element type
 * matches the expected type of the corresponding decoder.
 */
exports.sequence = function () {
    var decoders = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        decoders[_i] = arguments[_i];
    }
    return Decoder.of(function (input) {
        var buff = [];
        for (var i = 0; i < decoders.length; i++) {
            var decoder = decoders[i];
            var result = decoder.run(input);
            if (result.isFailure()) {
                return result_1.failure.apply(void 0, [input].concat(result.failures));
            }
            else {
                input = result.input;
                buff[i] = result.value;
            }
        }
        return result_1.success(input, buff);
    });
};
/**
 * Given an array of decoders, it traverses them all until one succeeds or they
 * all fail.
 */
exports.oneOf = function () {
    var decoders = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        decoders[_i] = arguments[_i];
    }
    if (decoders.length === 0)
        throw new Error('alt needs to be called with at least one argumenr');
    return Decoder.of(function (input) {
        var failures = [];
        for (var _i = 0, decoders_2 = decoders; _i < decoders_2.length; _i++) {
            var decoder = decoders_2[_i];
            var result = decoder.run(input);
            if (result.isFailure()) {
                failures = failures.concat(result.failures);
            }
            else {
                return result;
            }
        }
        return result_1.failure.apply(void 0, [input].concat(failures));
    });
};
/**
 * Returns a decoder that always succeeds with the given result. The decoder
 * doesn't consume anything from the input.
 */
exports.succeed = function (result) { return Decoder.of(function (input) { return result_1.success(input, result); }); };
/**
 * Returns a decoder that always fails with the given error.
 */
exports.fail = function (err) {
    return Decoder.of(function (input) { return result_1.failure(input, err); });
};
/**
 * Often time decoders are defined recursively. The language and type-system
 * do not allow for recursion. To work around that limit you create a `lazy`
 * decoder that wraps the desired decoder into a lazy function.
 *
 * The decoder function `f` is only invoked once and its result is reused
 * mutliple times if needed.
 */
exports.lazy = function (f) {
    var decoder;
    return Decoder.of(function (input) {
        if (decoder === undefined)
            decoder = f();
        return decoder.run(input);
    });
};
//# sourceMappingURL=decoder.js.map