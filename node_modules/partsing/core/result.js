"use strict";
/*
Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * {@link DecodeResult} is a union type that has two possible constructors
 * {@link DecodeSuccess} and {@link DecodeFailure}.
 *
 * `DecodeResultBase` is abstract and should never be used directly. It is
 * defined to provide a common signature to the only two possible constructors
 * {@link DecodeSuccess} and {@link DecodeFailure}.
 *
 * See `{@link DecodeResult}`.
 *
 */
var DecodeResultBase = /** @class */ (function () {
    /**
     * Construct an instance of `{@link DecodeResult}`. The only field that is shared
     * between `{@link DecodeSuccess}` and `{@link DecodeFailure}` is `input: In`.
     */
    function DecodeResultBase(input) {
        this.input = input;
    }
    return DecodeResultBase;
}());
/**
 * Type that represent a successful decoding of a value.
 */
var DecodeSuccess = /** @class */ (function (_super) {
    __extends(DecodeSuccess, _super);
    /**
     * Contruct an instance of `DecodeSuccess`.
     * @param input The input value that the next decoder should try to consume.
     * @param value The value generated from the decoding operation.
     */
    function DecodeSuccess(input, value) {
        var _this = _super.call(this, input) || this;
        _this.value = value;
        /**
         * Type discriminator
         */
        _this.kind = 'decode-success';
        return _this;
    }
    /**
     * See {@link DecodeResultBase.match}
     */
    DecodeSuccess.prototype.match = function (o) {
        return o.success(this);
    };
    /**
     * See {@link DecodeResultBase.flatMap}
     */
    DecodeSuccess.prototype.flatMap = function (f) {
        return f(this.value);
    };
    /**
     * See {@link DecodeResultBase.map}
     */
    DecodeSuccess.prototype.map = function (f) {
        var _this = this;
        return this.flatMap(function (v) { return exports.success(_this.input, f(v)); });
    };
    /**
     * See {@link DecodeResultBase.flatMapError}
     */
    DecodeSuccess.prototype.flatMapError = function (f) {
        return exports.success(this.input, this.value);
    };
    /**
     * See {@link DecodeResultBase.mapError}
     */
    DecodeSuccess.prototype.mapError = function (f) {
        return exports.success(this.input, this.value);
    };
    /**
     * See {@link DecodeResultBase.mapInput}
     */
    DecodeSuccess.prototype.mapInput = function (f) {
        return exports.success(f(this.input), this.value);
    };
    /**
     * See {@link DecodeResultBase.isSuccess}
     */
    DecodeSuccess.prototype.isSuccess = function () {
        return true;
    };
    /**
     * See {@link DecodeResultBase.isFailure}
     */
    DecodeSuccess.prototype.isFailure = function () {
        return false;
    };
    /**
     * See {@link DecodeResultBase.getUnsafeSuccess}
     */
    DecodeSuccess.prototype.getUnsafeSuccess = function () {
        return this.value;
    };
    /**
     * See {@link DecodeResultBase.getUnsafeFailures}
     */
    DecodeSuccess.prototype.getUnsafeFailures = function () {
        throw new Error("can't get failure from success");
    };
    /**
     * Provides a human readable representation of the value. Mostly for debugging.
     */
    DecodeSuccess.prototype.toString = function () {
        return "DecodeSuccess<" + JSON.stringify(this.value) + ">: " + JSON.stringify(this.input);
    };
    return DecodeSuccess;
}(DecodeResultBase));
exports.DecodeSuccess = DecodeSuccess;
/**
 * Type that represent a failed decoding.
 */
var DecodeFailure = /** @class */ (function (_super) {
    __extends(DecodeFailure, _super);
    /**
     * Contruct an instance of `DecodeFailure`.
     * @param input The input value that corresponds to the place where the decoder
     * failed to generate a valid result.
     * @param failures The error messages associated with the reason why the decoder
     * failed.
     */
    function DecodeFailure(input) {
        var failures = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            failures[_i - 1] = arguments[_i];
        }
        var _this = _super.call(this, input) || this;
        /**
         * Type discriminator
         */
        _this.kind = 'decode-failure';
        _this.failures = failures;
        return _this;
    }
    /**
     * See {@link DecodeResultBase.match}
     */
    DecodeFailure.prototype.match = function (o) {
        return o.failure(this);
    };
    /**
     * See {@link DecodeResultBase.flatMap}
     */
    DecodeFailure.prototype.flatMap = function (f) {
        return exports.failure.apply(void 0, [this.input].concat(this.failures));
    };
    /**
     * See {@link DecodeResultBase.map}
     */
    DecodeFailure.prototype.map = function (f) {
        return exports.failure.apply(void 0, [this.input].concat(this.failures));
    };
    /**
     * See {@link DecodeResultBase.flatMapError}
     */
    DecodeFailure.prototype.flatMapError = function (f) {
        return f(this.failures);
    };
    /**
     * See {@link DecodeResultBase.mapError}
     */
    DecodeFailure.prototype.mapError = function (f) {
        return exports.failure.apply(void 0, [this.input].concat(this.failures.map(f)));
    };
    /**
     * See {@link DecodeResultBase.mapInput}
     */
    DecodeFailure.prototype.mapInput = function (f) {
        return exports.failure.apply(void 0, [f(this.input)].concat(this.failures));
    };
    /**
     * See {@link DecodeResultBase.isSuccess}
     */
    DecodeFailure.prototype.isSuccess = function () {
        return false;
    };
    /**
     * See {@link DecodeResultBase.isFailure}
     */
    DecodeFailure.prototype.isFailure = function () {
        return true;
    };
    /**
     * See {@link DecodeResultBase.getUnsafeSuccess}
     */
    DecodeFailure.prototype.getUnsafeSuccess = function () {
        throw new Error("can't get success from failure");
    };
    /**
     * See {@link DecodeResultBase.getUnsafeFailure}
     */
    DecodeFailure.prototype.getUnsafeFailures = function () {
        return this.failures;
    };
    /**
     * Provides a human readable representation of the value. Mostly for debugging.
     */
    DecodeFailure.prototype.toString = function () {
        return "DecodeFailure<" + JSON.stringify(this.failures) + ">: " + JSON.stringify(this.input);
    };
    return DecodeFailure;
}(DecodeResultBase));
exports.DecodeFailure = DecodeFailure;
/**
 * Helper function to create an instance of `DecodeResult` from a succeeded decoding.
 */
exports.success = function (input, result) {
    return new DecodeSuccess(input, result);
};
/**
 * Helper function to create an instance of `DecodeResult` from a failed decoding.
 */
exports.failure = function (input) {
    var failures = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        failures[_i - 1] = arguments[_i];
    }
    return new (DecodeFailure.bind.apply(DecodeFailure, [void 0, input].concat(failures)))();
};
//# sourceMappingURL=result.js.map