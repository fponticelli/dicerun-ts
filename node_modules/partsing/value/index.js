"use strict";
/*
Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This module contains a set of decoders and utility functions to decode
 * JavaScript values. A typical scenario would be decoding the result of an AJAX
 * call after it has been processed by `JSON.parse`.
 */
var decoder_1 = require("../core/decoder");
var result_1 = require("../core/result");
var error_1 = require("../error");
var utils_1 = require("../utils");
/**
 * Utility function to generate a decoder of type `{@link ValueDecoder}` from a function `f`.
 */
var make = function (f) { return decoder_1.Decoder.of(f); };
/**
 * Helper function that return a function to decode from an `input` of type `any` to a `DecodeResult`.
 *
 * The function takes a `ValueDecoder` as the only argument.
 *
 * This convenience function exists because `ValueDecoder` requires an input of
 * type {@link ValueInput} and not just `any`.
 */
exports.decodeValue = function (decoder) { return function (input) {
    return decoder.run({ input: input, path: [] }).match({
        success: function (s) { return result_1.success(input, s.value); },
        failure: function (f) { return result_1.failure(input, exports.failureToString(f)); }
    });
}; };
/**
 * It expects an input of type `T` to pass the check made by the predicate
 * function `f`. Notice that testValue doesn't (cannot) check that the input
 * is really of type `T`. Such check must be performed by predicate itself.
 */
exports.testValue = function (f, expected) {
    return make(function (input) {
        return f(input.input) ? result_1.success(input, input.input) : result_1.failure(input, error_1.DecodeError.expectedMatch(error_1.Entity.PREDICATE, expected));
    });
};
/**
 * Given a type in `string` format, it checks that the current `input` matches it
 * using `typeof`.
 */
exports.testType = function (expected) {
    return make(function (input) {
        return typeof input.input === expected
            ? result_1.success(input, input.input)
            : result_1.failure(input, error_1.DecodeError.expectedMatch(error_1.Entity.TYPE, expected));
    });
};
/**
 * Transform a decoder into one that consumes either the value from the passed decoder
 * or `null`.
 */
exports.nullableValue = function (decoder) { return decoder.or(exports.nullValue); };
/**
 * Transform a decoder into one that consumes either the value from the passed decoder
 * or `undefined`.
 */
exports.undefineableValue = function (decoder) { return decoder.or(exports.undefinedValue); };
/**
 * Transform a decoder into one that consumes either the value from the passed decoder,
 * `null` or `undefined`.
 */
exports.optionalValue = function (decoder) { return decoder.or(exports.undefinedValue, exports.nullValue); };
/**
 * Decoder that always retun the input value as an untyped (`any`) value.
 */
exports.anyValue = make(function (input) { return result_1.success(input, input.input); });
/**
 * Decoder that matches a string value.
 */
exports.stringValue = exports.testType('string');
/**
 * Decoder that matches a numeric value.
 */
exports.numberValue = exports.testType('number');
/**
 * Decoder that matches an integer value.
 */
exports.integerValue = exports.numberValue.test(Number.isInteger, error_1.DecodeError.expectedMatch(error_1.Entity.TYPE, 'integer'));
/**
 * Decoder that matches a safe-integer value.
 */
exports.safeIntegerValue = exports.numberValue.test(Number.isSafeInteger, error_1.DecodeError.expectedMatch(error_1.Entity.TYPE, 'safe integer'));
/**
 * Decoder that matches a finite-number value.
 */
exports.finiteNumberValue = exports.numberValue.test(Number.isFinite, error_1.DecodeError.expectedMatch(error_1.Entity.TYPE, 'finite number'));
/**
 * Decoder that matches a boolean value.
 */
exports.booleanValue = exports.testType('boolean');
/**
 * Decoder that matches an `undefined` value.
 */
exports.undefinedValue = exports.testType('undefined');
/**
 * Decoder that matches a `null` value.
 */
exports.nullValue = exports.testValue(function (v) { return v === null; }, 'null')
    .withResult(null)
    .withFailure(error_1.DecodeError.expectedMatch(error_1.Entity.TYPE, 'null'));
/**
 * A decoder that doesn't consume any input but does return the current path
 * position as its result value.
 */
exports.currentPath = make(function (input) { return result_1.success(input, input.path); });
/**
 * Decoder that matches exactly a specified literal value of type `T`.
 *
 * By default this function uses strict equality. If that is not the desired
 * behavior, an equality function can be provided.
 */
exports.literalValue = function (value, eq) {
    if (eq === void 0) { eq = function (a, b) { return a === b; }; }
    return exports.testValue(function (v) { return eq(v, value); }, String(value))
        .withResult(value)
        .withFailure(error_1.DecodeError.expectedMatch(error_1.Entity.LITERAL, "" + value));
};
/**
 * Decoder that matches an array. Element values are not decoded and are typed
 * as `any`.
 */
exports.anyArrayValue = exports.testValue(Array.isArray, 'array');
/**
 * Create a decoder that matches an array. Each element is decoded applying
 * the passed `decoder` argument.
 */
exports.arrayValue = function (decoder) {
    return exports.anyArrayValue.flatMap(function (values) {
        return make(function (input) {
            var length = values.length;
            var buff = new Array(length);
            for (var i = 0; i < length; i++) {
                var s = { input: values[i], path: input.path.concat([i]) };
                var r = decoder.run(s);
                if (r.isSuccess()) {
                    buff[i] = r.value;
                }
                else {
                    return result_1.failure.apply(void 0, [r.input].concat(r.failures));
                }
            }
            return result_1.success(input, buff);
        });
    });
};
/**
 * It creates a tuple decoder by passing any number of decoders.
 *
 * The number of expected elements in the tuple must match the number of provided
 * decoders.
 */
exports.tupleValue = function () {
    var decoders = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        decoders[_i] = arguments[_i];
    }
    return exports.anyArrayValue.flatMap(function (values) {
        return make(function (input) {
            var length = values.length;
            var buff = new Array(length);
            for (var i = 0; i < length; i++) {
                var s = { input: values[i], path: input.path.concat([i]) };
                var r = decoders[i].run(s);
                if (r.isSuccess()) {
                    buff[i] = r.value;
                }
                else {
                    return result_1.failure.apply(void 0, [r.input].concat(r.failures));
                }
            }
            return result_1.success(input, buff);
        });
    });
};
/**
 * Decoder that validates a value to be an object.
 */
exports.testObject = exports.testType('object').flatMap(function (value) {
    return decoder_1.Decoder.of(function (input) {
        if (Array.isArray(value)) {
            return result_1.failure(input, error_1.DecodeError.expectedMatch(error_1.Entity.TYPE, 'not array'));
        }
        else {
            return result_1.success(input, value);
        }
    });
});
/**
 * Create a decoder to validate objects.
 *
 * Each field in the passed object argument `fieldDecoders` is a distinct decoder
 * for a matching field in the input object.
 *
 * The second argument `optionalFields`, marks the fields to consider optionals.
 */
function objectValue(fieldDecoders, optionalFields) {
    return exports.testObject.flatMap(function (o) {
        return make(function (input) {
            var mandatoryFields = Object.keys(fieldDecoders).filter(function (f) { return optionalFields.indexOf(f) < 0; });
            var buff = {};
            for (var _i = 0, mandatoryFields_1 = mandatoryFields; _i < mandatoryFields_1.length; _i++) {
                var field = mandatoryFields_1[_i];
                if (o.hasOwnProperty(field)) {
                    var s = { input: o[field], path: input.path.concat([field]) };
                    var result = fieldDecoders[field].run(s);
                    if (result.isSuccess()) {
                        buff[field] = result.value;
                    }
                    else {
                        return result_1.failure.apply(void 0, [result.input].concat(result.failures));
                    }
                }
                else {
                    return result_1.failure(input, error_1.DecodeError.expectedField(field));
                }
            }
            for (var _a = 0, optionalFields_1 = optionalFields; _a < optionalFields_1.length; _a++) {
                var field = optionalFields_1[_a];
                if (o.hasOwnProperty(field)) {
                    var s = { input: o[field], path: input.path.concat([field]) };
                    var result = fieldDecoders[field].run(s);
                    if (result.isSuccess()) {
                        buff[field] = result.value;
                    }
                    else {
                        return result_1.failure.apply(void 0, [result.input].concat(result.failures));
                    }
                }
            }
            return result_1.success(input, buff);
        });
    });
}
exports.objectValue = objectValue;
/**
 * Decodes an object applying a decoder for the keys and one for values of each
 * field pair.
 */
exports.recordValue = function (keyDecoder, valueDecoder) {
    return exports.testObject.flatMap(function (o) {
        return make(function (input) {
            var buff = {};
            for (var _i = 0, _a = Object.keys(o); _i < _a.length; _i++) {
                var field = _a[_i];
                var keyResult = keyDecoder.run({ input: field, path: input.path });
                if (keyResult.isSuccess()) {
                    var key = keyResult.value;
                    var value = o[field];
                    var valueResult = valueDecoder.run({ input: value, path: input.path.concat([field]) });
                    if (valueResult.isSuccess()) {
                        buff[key] = valueResult.value;
                    }
                    else {
                        return result_1.failure.apply(void 0, [valueResult.input].concat(valueResult.failures));
                    }
                }
                else {
                    return result_1.failure.apply(void 0, [keyResult.input].concat(keyResult.failures));
                }
            }
            return result_1.success(input, buff);
        });
    });
};
/**
 * Same as {@link recodValue} enforcing string keys.
 */
exports.stringRecordValue = function (valueDecoder) {
    return exports.recordValue(exports.stringValue, valueDecoder);
};
/**
 * Pretty prints a `DecodeFailure<ValueInput, Out, DecodeError>`.
 */
exports.failureToString = function (err) {
    var failures = err.failures, input = err.input;
    var expected = failures.length === 1 ? failures[0].toString() : "one of:\n * " + failures.map(function (v) { return v.toString(); }).join('\n * ') + "\n";
    var msg = expected + " but got " + utils_1.valueToString(input.input);
    var path = utils_1.pathToString(input.path);
    if (path === '')
        return msg;
    else
        return "expected " + msg + " at " + path;
};
//# sourceMappingURL=index.js.map