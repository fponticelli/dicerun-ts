/**
 * This module contains a set of decoders and utility functions to decode
 * JavaScript values. A typical scenario would be decoding the result of an AJAX
 * call after it has been processed by `JSON.parse`.
 */
import { Decoder } from '../core/decoder';
import { DecodeFailure, DecodeResult } from '../core/result';
import { MarkOptionalFields } from '../core/type_level';
import { DecodeError } from '../error';
/**
 * `ValueInput` stores the current `input` value as a `any` (any JS value) and
 * contains a `path` value to identify the position in the current context.
 *
 * `path` is an array of either `string` values (field names of an object) or
 * `number` values (index inside an array).
 */
export interface ValueInput {
    /**
     * The input JavaScript value. It can be any value of any type.
     *
     * When decoders traverse an array or object value, they will pass only the
     * currently inspected element to the next decoder and not the source value.
     */
    readonly input: any;
    /**
     * The current path for this value input.
     */
    readonly path: (string | number)[];
}
/**
 * Type alias for a decoder specialized in consuming values of type `{@link ValueInput}`
 * and generate errors of type `{@link DecodeError}`.
 */
export declare type ValueDecoder<T> = Decoder<ValueInput, T, DecodeError>;
/**
 * Helper function that return a function to decode from an `input` of type `any` to a `DecodeResult`.
 *
 * The function takes a `ValueDecoder` as the only argument.
 *
 * This convenience function exists because `ValueDecoder` requires an input of
 * type {@link ValueInput} and not just `any`.
 */
export declare const decodeValue: <T>(decoder: Decoder<ValueInput, T, DecodeError>) => (input: any) => DecodeResult<any, T, string>;
/**
 * It expects an input of type `T` to pass the check made by the predicate
 * function `f`. Notice that testValue doesn't (cannot) check that the input
 * is really of type `T`. Such check must be performed by predicate itself.
 */
export declare const testValue: <T>(f: (input: T) => boolean, expected: string) => Decoder<ValueInput, T, DecodeError>;
/**
 * Given a type in `string` format, it checks that the current `input` matches it
 * using `typeof`.
 */
export declare const testType: <T>(expected: string) => Decoder<ValueInput, T, DecodeError>;
/**
 * Transform a decoder into one that consumes either the value from the passed decoder
 * or `null`.
 */
export declare const nullableValue: <T>(decoder: Decoder<ValueInput, T, DecodeError>) => Decoder<ValueInput, T | null, DecodeError>;
/**
 * Transform a decoder into one that consumes either the value from the passed decoder
 * or `undefined`.
 */
export declare const undefineableValue: <T>(decoder: Decoder<ValueInput, T, DecodeError>) => Decoder<ValueInput, T | undefined, DecodeError>;
/**
 * Transform a decoder into one that consumes either the value from the passed decoder,
 * `null` or `undefined`.
 */
export declare const optionalValue: <T>(decoder: Decoder<ValueInput, T, DecodeError>) => Decoder<ValueInput, T | null | undefined, DecodeError>;
/**
 * Decoder that always retun the input value as an untyped (`any`) value.
 */
export declare const anyValue: Decoder<ValueInput, any, DecodeError>;
/**
 * Decoder that matches a string value.
 */
export declare const stringValue: Decoder<ValueInput, string, DecodeError>;
/**
 * Decoder that matches a numeric value.
 */
export declare const numberValue: Decoder<ValueInput, number, DecodeError>;
/**
 * Decoder that matches an integer value.
 */
export declare const integerValue: Decoder<ValueInput, number, DecodeError>;
/**
 * Decoder that matches a safe-integer value.
 */
export declare const safeIntegerValue: Decoder<ValueInput, number, DecodeError>;
/**
 * Decoder that matches a finite-number value.
 */
export declare const finiteNumberValue: Decoder<ValueInput, number, DecodeError>;
/**
 * Decoder that matches a boolean value.
 */
export declare const booleanValue: Decoder<ValueInput, boolean, DecodeError>;
/**
 * Decoder that matches an `undefined` value.
 */
export declare const undefinedValue: Decoder<ValueInput, undefined, DecodeError>;
/**
 * Decoder that matches a `null` value.
 */
export declare const nullValue: Decoder<ValueInput, null, DecodeError>;
/**
 * A decoder that doesn't consume any input but does return the current path
 * position as its result value.
 */
export declare const currentPath: Decoder<ValueInput, (string | number)[], DecodeError>;
/**
 * Decoder that matches exactly a specified literal value of type `T`.
 *
 * By default this function uses strict equality. If that is not the desired
 * behavior, an equality function can be provided.
 */
export declare const literalValue: <T>(value: T, eq?: (a: T, b: T) => boolean) => Decoder<ValueInput, T, DecodeError>;
/**
 * Decoder that matches an array. Element values are not decoded and are typed
 * as `any`.
 */
export declare const anyArrayValue: Decoder<ValueInput, any[], DecodeError>;
/**
 * Create a decoder that matches an array. Each element is decoded applying
 * the passed `decoder` argument.
 */
export declare const arrayValue: <T>(decoder: Decoder<ValueInput, T, DecodeError>) => Decoder<ValueInput, T[], DecodeError>;
/**
 * It creates a tuple decoder by passing any number of decoders.
 *
 * The number of expected elements in the tuple must match the number of provided
 * decoders.
 */
export declare const tupleValue: <U extends any[]>(...decoders: { [k in keyof U]: Decoder<ValueInput, U[k], DecodeError>; }) => Decoder<ValueInput, U, DecodeError>;
/**
 * Decoder that validates a value to be an object.
 */
export declare const testObject: Decoder<ValueInput, unknown, DecodeError>;
/**
 * Create a decoder to validate objects.
 *
 * Each field in the passed object argument `fieldDecoders` is a distinct decoder
 * for a matching field in the input object.
 *
 * The second argument `optionalFields`, marks the fields to consider optionals.
 */
export declare function objectValue<T extends {}, K extends keyof T = keyof T>(fieldDecoders: {
    [K in keyof T]: ValueDecoder<T[K]>;
}, optionalFields: [...K[]]): ValueDecoder<MarkOptionalFields<T, typeof optionalFields>>;
/**
 * Decodes an object applying a decoder for the keys and one for values of each
 * field pair.
 */
export declare const recordValue: <K extends string | number | symbol, T>(keyDecoder: Decoder<ValueInput, K, DecodeError>, valueDecoder: Decoder<ValueInput, T, DecodeError>) => Decoder<ValueInput, Record<K, T>, DecodeError>;
/**
 * Same as {@link recodValue} enforcing string keys.
 */
export declare const stringRecordValue: <T>(valueDecoder: Decoder<ValueInput, T, DecodeError>) => Decoder<ValueInput, Record<string, T>, DecodeError>;
/**
 * Pretty prints a `DecodeFailure<ValueInput, Out, DecodeError>`.
 */
export declare const failureToString: <Out>(err: DecodeFailure<ValueInput, Out, DecodeError>) => string;
