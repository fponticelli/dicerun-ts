import { Prop } from '../prop';
import { makeRenderable } from '../jsx-runtime';
export class OneOfImpl {
    match;
    cases;
    constructor(match, cases) {
        this.match = match;
        this.cases = cases;
    }
    appendTo = (ctx) => {
        const pair = this.match.get();
        let key = pair[0];
        const value = pair[1];
        const stableCtx = ctx.makeReference();
        let prop = new Prop(value);
        let newCtx = stableCtx.makeReference();
        let clear = makeRenderable(this.cases[key](prop)).appendTo(newCtx);
        const cancel = this.match.subscribe(([newKey, newValue]) => {
            if (newKey !== key) {
                newCtx.requestClear(true, () => {
                    newCtx = stableCtx.makeReference();
                    key = newKey;
                    prop.clean();
                    prop = new Prop(newValue);
                    clear(true);
                    clear = makeRenderable(this.cases[key](prop)).appendTo(newCtx);
                });
            }
            else {
                prop.set(newValue);
            }
        });
        return (removeTree) => {
            newCtx.requestClear(removeTree, () => {
                cancel();
                prop.clean();
                stableCtx.requestClear(removeTree, () => { });
            });
        };
    };
}
// <OneOf match={counter.map(v => v % 2 == 0 ? [1, "odd"] : [2, "even"])} 1={t => <b>{t}</b>} 2={t => <i>{t}</i>} /
export function OneOf(props) {
    return new OneOfImpl(props.match, props);
}
