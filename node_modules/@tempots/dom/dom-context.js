function extractClassNames(cls) {
    return (cls ?? '').split(/\s+/g).filter((className) => className.length > 0);
}
function createIntegerSet(x) {
    const integerSet = new Set();
    for (let i = 0; i < x; i++) {
        integerSet.add(i);
    }
    return integerSet;
}
export function makeProviderMark() {
    return Symbol('providerMark');
}
export class DOMContext {
    document;
    element;
    reference;
    ns;
    providers;
    static of(element) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return new DOMContext(element.ownerDocument, element, undefined, undefined, {});
    }
    constructor(document, element, reference, ns, providers) {
        this.document = document;
        this.element = element;
        this.reference = reference;
        this.ns = ns;
        this.providers = providers;
    }
    append(node) {
        if (this.reference !== undefined) {
            try {
                // There are components (TextContent, InnerHTML) that can mess up with the internal state of an element
                this.element.insertBefore(node, this.reference);
            }
            catch (_) {
                this.element.appendChild(node);
            }
        }
        else {
            this.element.appendChild(node);
        }
    }
    getElement() {
        return this.element;
    }
    getDocument() {
        return this.document;
    }
    makeReference() {
        const textNode = this.document.createTextNode('');
        this.append(textNode);
        return new DOMContext(this.document, this.element, textNode, this.ns, this.providers);
    }
    makeElement(tagName) {
        if (this.ns !== undefined || tagName === 'svg') {
            const ns = this.ns ?? 'http://www.w3.org/2000/svg';
            const element = this.document.createElementNS(ns, tagName);
            this.append(element);
            return new DOMContext(this.document, element, undefined, ns, this.providers);
        }
        else {
            const element = this.document.createElement(tagName);
            this.append(element);
            return new DOMContext(this.document, element, undefined, this.ns, this.providers);
        }
    }
    getBooleanAttribute(name) {
        return this.element.hasAttribute(name);
    }
    setBooleanAttribute(name, value) {
        if (value) {
            this.element.setAttribute(name, '');
        }
        else {
            this.element.removeAttribute(name);
        }
    }
    createBooleanAttribute(name, value) {
        const current = this.element.hasAttribute(name);
        this.setBooleanAttribute(name, value);
        return [
            (newValue) => {
                this.setBooleanAttribute(name, newValue);
            },
            (removeTree) => {
                if (removeTree) {
                    this.setBooleanAttribute(name, current);
                }
            }
        ];
    }
    getAttribute(name) {
        return this.element.getAttribute(name);
    }
    setAttribute(name, value) {
        if (value == null) {
            this.element.removeAttribute(name);
        }
        else {
            this.element.setAttribute(name, value);
        }
    }
    createAttribute(name, value) {
        const current = this.element.getAttribute(name);
        this.setAttribute(name, value);
        return [
            (newValue) => {
                this.setAttribute(name, newValue);
            },
            (removeTree) => {
                if (removeTree) {
                    this.setAttribute(name, current);
                }
            }
        ];
    }
    getProperty(name) {
        return Reflect.get(this.element, name);
    }
    setProperty(name, value) {
        if (value == null) {
            Reflect.deleteProperty(this.element, name);
        }
        else {
            Reflect.set(this.element, name, value);
        }
    }
    createProperty(name, value) {
        const current = this.getProperty(name);
        this.setProperty(name, value);
        return [
            (newValue) => {
                this.setProperty(name, newValue);
            },
            (removeTree) => {
                if (removeTree) {
                    this.setProperty(name, current);
                }
            }
        ];
    }
    createText(text) {
        const textNode = this.document.createTextNode(text);
        this.append(textNode);
        return [
            (newText) => {
                textNode.nodeValue = newText;
            },
            (removeTree) => {
                if (removeTree) {
                    textNode.remove();
                }
            }
        ];
    }
    createClass(cls) {
        let current = extractClassNames(cls);
        current.forEach((className) => {
            this.element.classList.add(className);
        });
        return [
            (newClass) => {
                current.forEach((className) => {
                    this.element.classList.remove(className);
                });
                current = extractClassNames(newClass);
                current.forEach((className) => {
                    this.element.classList.add(className);
                });
            },
            (removeTree) => {
                if (removeTree) {
                    current.forEach((className) => {
                        this.element.classList.remove(className);
                        if (this.element.classList.length === 0) {
                            this.element.removeAttribute('class');
                        }
                    });
                }
            }
        ];
    }
    createHandler(name, handler) {
        this.element.addEventListener(name, handler);
        return (removeTree) => {
            if (removeTree) {
                this.element.removeEventListener(name, handler);
            }
        };
    }
    suspendedClears = [];
    delayClear(f) {
        this.suspendedClears.push(f);
        return (removeTree) => {
            // TODO nothing happens?
        };
    }
    requestClear(removeTree, willClear) {
        if (this.suspendedClears.length === 0) {
            willClear();
            this.clear(removeTree);
        }
        else {
            const set = createIntegerSet(this.suspendedClears.length);
            const clearSuspended = (index) => {
                set.delete(index);
                if (set.size === 0) {
                    willClear();
                    this.clear(removeTree);
                }
            };
            this.suspendedClears.forEach((f, i) => { f(removeTree, () => { clearSuspended(i); }); });
            this.suspendedClears.length = 0;
        }
    }
    clear(removeTree) {
        if (removeTree) {
            if (this.reference !== undefined) {
                this.reference.parentElement?.removeChild(this.reference);
            }
            else {
                this.element.onblur = null;
                this.element.parentElement?.removeChild(this.element);
            }
        }
    }
    withProvider(mark, provider) {
        return new DOMContext(this.document, this.element, this.reference, this.ns, {
            ...this.providers,
            [mark]: provider
        });
    }
    getProvider(mark) {
        return this.providers[mark];
    }
    setStyle(name, value) {
        if (value == null) {
            this.element.style.removeProperty(name);
        }
        else {
            this.element.style.setProperty(name, value);
        }
    }
    createStyle(name, value) {
        const current = this.element.style.getPropertyValue(name);
        this.setStyle(name, value);
        return [
            (newValue) => {
                this.setStyle(name, newValue);
            },
            (removeTree) => {
                if (removeTree) {
                    this.setStyle(name, current);
                }
            }
        ];
    }
}
