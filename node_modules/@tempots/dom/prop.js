const $isSignal = Symbol('isSignal');
const $isProp = Symbol('isProp');
export class Signal {
    _value;
    static of(value) {
        return new Signal(value);
    }
    static ofValue(value) {
        return value == null ? undefined : Signal.wrap(value);
    }
    static wrap(value) {
        return Signal.isSignal(value) ? value : new Signal(value);
    }
    static isSignal(x) {
        const s = x;
        return s != null && typeof s.get === 'function' && typeof s.subscribe === 'function';
    }
    /**
     * Combines many into one using a merging function
     */
    static combine(others, f) {
        function getValues(others) {
            return others.map(other => other.get());
        }
        const prop = new Prop(f(...getValues(others)));
        others.forEach((other) => {
            other.subscribe(() => {
                prop.set(f(...getValues(others)));
            });
        });
        return prop;
    }
    [$isSignal] = true;
    _listeners = [];
    constructor(_value) {
        this._value = _value;
    }
    get = () => {
        return this._value;
    };
    subscribe = (listener) => {
        this._listeners.push(listener);
        return () => {
            const index = this._listeners.indexOf(listener);
            if (index >= 0) {
                this._listeners.splice(index, 1);
            }
        };
    };
    map = (f) => {
        const prop = new Prop(f(this._value));
        this.subscribe(value => { prop.set(f(value)); });
        return prop;
    };
    flatMap = (f) => {
        let signal = f(this._value);
        const prop = new Prop(signal.get());
        this.subscribe(value => {
            signal.clean();
            signal = f(value);
            signal.subscribe(value => { prop.set(value); });
        });
        return prop;
    };
    tap = (f) => {
        f(this._value);
        this.subscribe(f);
        return this;
    };
    at = (key) => {
        return this.map(value => value[key]);
    };
    filter = (predicate) => {
        const prop = new Prop(this._value);
        this.subscribe(value => {
            if (predicate(value)) {
                prop.set(value);
            }
        });
        return prop;
    };
    distinct = (equality) => {
        let lastValue = this._value;
        return this.filter(value => {
            const result = !equality(value, lastValue);
            lastValue = value;
            return result;
        });
    };
    mapAsync = (f, alt) => {
        let counter = 0;
        const prop = new Prop(alt);
        f(this._value)
            .then(value => {
            if (counter === 0)
                prop.set(value);
        })
            .catch(e => {
            throw e;
        });
        this.subscribe(value => {
            const matchCounter = ++counter;
            f(value)
                .then(value => {
                if (matchCounter === counter) {
                    prop.set(value);
                }
            })
                .catch(e => {
                throw e;
            });
        });
        return prop;
    };
    mapMaybe = (f, alt) => {
        const prop = new Prop(f(this._value) ?? alt);
        this.subscribe(value => {
            const newValue = f(value);
            if (newValue != null)
                prop.set(newValue);
        });
        return prop;
    };
    combine = (other, f) => {
        const prop = new Prop(f(this._value, other.get()));
        this.subscribe(value => { prop.set(f(value, other.get())); });
        other.subscribe(value => { prop.set(f(this._value, value)); });
        return prop;
    };
    feed = (prop) => {
        this.subscribe(value => { prop.set(value); });
        return prop;
    };
    deriveProp = () => {
        return new Prop(this._value);
    };
    clean = () => {
        this._listeners.length = 0;
    };
}
export class Prop extends Signal {
    static isProp(x) {
        const p = x;
        return Signal.isSignal(x) && typeof p.set === 'function';
        // return x != null && (x as Prop<T>)[$isProp] === true
    }
    static of(value) {
        return new Prop(value);
    }
    [$isProp] = true;
    set = (value) => {
        if (this._value === value)
            return;
        this._value = value;
        this._listeners.forEach(listener => { listener(value); });
    };
    update = (f) => {
        this.set(f(this._value));
    };
    atLens = (key) => {
        return this.iso(value => value[key], value => ({ ...this._value, [key]: value }));
    };
    reducer = (f) => {
        return (action) => {
            this.set(f(this._value, action));
        };
    };
    iso = (map, reverse) => {
        const prop = new Prop(map(this._value));
        this.subscribe(value => { prop.set(map(value)); });
        prop.subscribe(value => { this.set(reverse(value)); });
        return prop;
    };
}
