export type ArgsToSignals<T extends [...unknown[]]> = T extends [] ? [] : T extends [infer U, ...infer V] ? [Signal<U>, ...ArgsToSignals<V>] : [];
declare const $isSignal: unique symbol;
declare const $isProp: unique symbol;
export type Value<T> = T | Signal<T>;
export declare class Signal<T> {
    protected _value: T;
    static of<T>(value: T): Signal<T>;
    static ofValue<T>(value: Value<T> | null | undefined): Signal<T> | undefined;
    static wrap<T>(value: T | Signal<T>): Signal<T>;
    static isSignal<T = unknown>(x: unknown): x is Signal<T>;
    /**
     * Combines many into one using a merging function
     */
    static combine<Args extends [...unknown[]], Out>(others: ArgsToSignals<Args>, f: (...args: Args) => Out): Signal<Out>;
    readonly [$isSignal] = true;
    protected readonly _listeners: Array<(value: T) => void>;
    constructor(_value: T);
    readonly get: () => T;
    readonly subscribe: (listener: (value: T) => void) => () => void;
    readonly map: <V>(f: (value: T) => V) => Signal<V>;
    readonly flatMap: <V>(f: (value: T) => Signal<V>) => Signal<V>;
    readonly tap: (f: (value: T) => void) => this;
    readonly at: <K extends keyof T>(key: K) => Signal<T[K]>;
    readonly filter: (predicate: (value: T) => boolean) => Signal<T>;
    readonly distinct: (equality: (a: T, b: T) => boolean) => Signal<T>;
    readonly mapAsync: <V>(f: (value: T) => Promise<V>, alt: V) => Signal<V>;
    readonly mapMaybe: <V>(f: (value: T) => V | null | undefined, alt: V) => Signal<V>;
    readonly combine: <V, Z>(other: Signal<V>, f: (a: T, b: V) => Z) => Signal<Z>;
    readonly feed: (prop: Prop<T>) => Prop<T>;
    readonly deriveProp: () => Prop<T>;
    readonly clean: () => void;
}
export declare class Prop<T> extends Signal<T> {
    static isProp<T = unknown>(x: unknown): x is Prop<T>;
    static of<T>(value: T): Prop<T>;
    readonly [$isProp] = true;
    readonly set: (value: T) => void;
    readonly update: (f: (value: T) => T) => void;
    readonly atLens: <K extends keyof T>(key: K) => Prop<T[K]>;
    readonly reducer: <V>(f: (state: T, action: V) => T) => (action: V) => void;
    readonly iso: <V>(map: (value: T) => V, reverse: (value: V) => T) => Prop<V>;
}
export {};
