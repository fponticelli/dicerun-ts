/**
 *
 */
import { type Pointer, type DeRef } from './generic';
export type Tail<T extends any[]> = ((...args: T) => void) extends (_: any, ...rest: infer Rest) => void ? Rest : never;
type DropNImpl<N extends number, T extends any[], I extends any[]> = {
    return: T;
    next: DropNImpl<N, Tail<T>, Prepend<any, I>>;
}[Length<I> extends N ? 'return' : 'next'];
export type DropN<N extends number, T extends any[]> = DropNImpl<N, T, []>;
type ReverseImpl<T extends any[], R extends any[], I extends any[]> = {
    return: DeRef<Pointer<R>>;
    next: ReverseImpl<T, Prepend<T[Length<I>], R>, Prepend<any, I>>;
}[Length<I> extends Length<T> ? 'return' : 'next'];
export type Reverse<T extends any[]> = ReverseImpl<T, [], []>;
export type Head<T extends any[]> = T extends [infer H, ...any[]] ? H : never;
export type Last<T extends any[]> = {
    n: Last<Tail<T>>;
    one: T extends [infer H] ? H : never;
    empty: never;
}[T extends [] ? 'empty' : T extends [any] ? 'one' : 'n'];
export type TupleToUnion<T extends any[]> = T[number];
export type Prepend<Insert, Tail extends any[]> = [Insert, ...Tail];
export type Append<Tuple extends any[], Element> = [...Tuple, Element];
export type Length<T extends any[]> = T['length'];
export type LoseLastImpl<A extends any[], B extends any[]> = {
    empty: A;
    next: LoseLastImpl<Prepend<B[0], A>, Tail<B>>;
}[B extends [] ? 'empty' : B extends [any] ? 'empty' : 'next'];
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type LastOf<T> = UnionToIntersection<T extends any ? () => T : never> extends () => infer R ? R : never;
export type Push<T extends any[], V> = [...T, V];
export type UnionToTuple<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<UnionToTuple1<Exclude<T, L>>, L>;
type UnionToTuple1<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<UnionToTuple2<Exclude<T, L>>, L>;
type UnionToTuple2<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<UnionToTuple3<Exclude<T, L>>, L>;
type UnionToTuple3<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<UnionToTuple4<Exclude<T, L>>, L>;
type UnionToTuple4<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<UnionToTuple5<Exclude<T, L>>, L>;
type UnionToTuple5<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<UnionToTuple6<Exclude<T, L>>, L>;
type UnionToTuple6<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<UnionToTuple7<Exclude<T, L>>, L>;
type UnionToTuple7<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<UnionToTuple8<Exclude<T, L>>, L>;
type UnionToTuple8<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<UnionToTuple9<Exclude<T, L>>, L>;
type UnionToTuple9<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<UnionToTupleX<Exclude<T, L>>, L>;
type UnionToTupleX<T> = never;
export {};
