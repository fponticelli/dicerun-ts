import { type Tail } from './tuples';
export type Equality<T> = (a: T, b: T) => boolean;
export type Effect<T> = (value: T) => void;
export type Proc = () => void;
export type Lazy<T> = () => T;
export type Fun = (...args: any[]) => any;
export type Fun1<A, T> = (a1: A) => T;
export type Fun2<A, B, T> = (a1: A, a2: B) => T;
export type Fun3<A, B, C, T> = (a1: A, a2: B, a3: C) => T;
export type Fun4<A, B, C, D, T> = (a1: A, a2: B, a3: C, a4: D) => T;
export type Fun5<A, B, C, D, E, T> = (a1: A, a2: B, a3: C, a4: D, a5: E) => T;
export type Fun6<A, B, C, D, E, F, T> = (a1: A, a2: B, a3: C, a4: D, a5: E, a6: F) => T;
export type AnyFunction = Fun | Function;
export type FirstArgument<F extends AnyFunction> = F extends (a: infer A) => any ? unknown extends A ? never : A : never;
export type OnlyIfDoesNotReturnNever<F extends Fun> = F extends Fun1<any, never> ? never : F;
type CheckFunctionsChain<In, Args extends Array<Fun1<any, any>>> = {
    empty: (i: In) => In;
    one: FirstArgument<Args[0]> extends In ? Args[0] : never;
    n: FirstArgument<Args[0]> extends In ? (arg: FirstArgument<Args[0]>) => ReturnType<CheckFunctionsChain<ReturnType<Args[0]>, Tail<Args>>> : never;
}[Args extends [] ? 'empty' : Args extends [any] ? 'one' : 'n'];
export type FunctionsChain<In, Args extends Fun[]> = OnlyIfDoesNotReturnNever<CheckFunctionsChain<In, Args>>;
export {};
