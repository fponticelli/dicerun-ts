/**
 *
 */
import { type AnyKey } from './utility';
import { type Tail } from './tuples';
import { type AnyFunction } from './functions';
import { type WhenEquals } from './generic';
export type ObjectWithField<F extends AnyKey, V> = {
    [_ in F]: V;
};
export type ObjectWithPath<Path extends AnyKey[], V> = Path extends [] ? {} : Path extends [infer T] ? T extends AnyKey ? {
    [_ in T]: V;
} : never : Path extends [infer K, ...any[]] ? K extends AnyKey ? Tail<Path> extends infer Rest ? Rest extends AnyKey[] ? {
    [_ in K]: ObjectWithPath<Rest, V>;
} : never : never : never : never;
export type TypeAtPath<Path extends AnyKey[], O> = {
    next: Path extends [infer K, ...any[]] ? K extends AnyKey ? Tail<Path> extends infer Rest ? O extends Record<AnyKey, any> ? Rest extends AnyKey[] ? TypeAtPath<Rest, O[K]> : never : never : never : never : never;
    empty: O;
    done: O extends Record<AnyKey, any> ? Path extends [infer K] ? K extends AnyKey ? O[K] : never : never : never;
}[Path extends [] ? 'empty' : Path extends [any] ? 'done' : 'next'];
export type WritableKeys<T> = {
    [K in keyof T]-?: WhenEquals<{
        [Q in K]: T[K];
    }, {
        -readonly [Q in K]: T[K];
    }, K>;
}[keyof T];
export type ReadonlyKeys<T> = {
    [P in keyof T]-?: WhenEquals<{
        [Q in P]: T[P];
    }, {
        -readonly [Q in P]: T[P];
    }, never, P>;
}[keyof T];
export type Id<T> = {} & {
    [P in keyof T]: T[P];
};
export type KeysWithFieldType<T, Condition> = {
    [K in keyof T]: WhenEquals<T[K], Condition, K>;
}[keyof T];
export type KeysWithoutFieldType<T, Condition> = {
    [K in keyof T]: WhenEquals<T[K], Condition, never, K>;
}[keyof T];
export type RemoveNullableFromFields<T> = {
    [K in keyof T]: NonNullable<T[K]>;
};
export type WritableFields<T> = Pick<T, WritableKeys<T>>;
export type ReadonlyFields<T> = Pick<T, ReadonlyKeys<T>>;
export type ExcludeFunctionFields<T> = Pick<T, KeysWithoutFieldType<T, AnyFunction>>;
export type Merge<A, B> = Id<A & B>;
