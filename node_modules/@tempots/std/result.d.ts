import { type AsyncResult } from './async-result';
export interface Success<V> {
    type: 'success';
    value: V;
}
export interface Failure<E> {
    type: 'failure';
    error: E;
}
export type Result<V, E> = Success<V> | Failure<E>;
export type PromiseResult<V, E> = PromiseLike<Result<V, E>>;
export declare const Result: {
    success<V>(value: V): Result<V, any>;
    failure<E>(error: E): Result<any, E>;
    cmap: <V1, V2, E_1>(f: (value: V1) => V2) => (r: Result<V1, E_1>) => Result<V2, E_1>;
    map: <V1_1, V2_1, E_2>(r: Result<V1_1, E_2>, f: (value: V1_1) => V2_1) => Result<V2_1, E_2>;
    cflatMap: <V1_2, V2_2, E_3>(f: (value: V1_2) => Result<V2_2, E_3>) => (r: Result<V1_2, E_3>) => Result<V2_2, E_3>;
    flatMap: <V1_3, V2_3, E_4>(r: Result<V1_3, E_4>, f: (value: V1_3) => Result<V2_3, E_4>) => Result<V2_3, E_4>;
    toAsync<V_1, E_5>(r: Result<V_1, E_5>): AsyncResult<V_1, E_5>;
    isSuccess<V_2, E_6>(r: Result<V_2, E_6>): r is Success<V_2>;
    isFailure<V_3, E_7>(r: Result<V_3, E_7>): r is Failure<E_7>;
    getOrElse<V_4, E_8>(r: Result<V_4, E_8>, alt: V_4): V_4;
    getOrElseLazy<V_5, E_9>(r: Result<V_5, E_9>, altf: () => V_5): V_5;
    getOrNull<V_6, E_10>(r: Result<V_6, E_10>): V_6 | null;
    getOrUndefined<V_7, E_11>(r: Result<V_7, E_11>): V_7 | undefined;
    cmatch: <V1_4, V2_4, E_12>(success: (value: V1_4) => V2_4, failure: (error: E_12) => V2_4) => (r: Result<V1_4, E_12>) => V2_4;
    match: <V1_5, V2_5, E_13>(r: Result<V1_5, E_13>, success: (value: V1_5) => V2_5, failure: (error: E_13) => V2_5) => V2_5;
    whenSuccess: <V_8, E_14>(apply: (v: V_8) => void) => (r: Result<V_8, E_14>) => Result<V_8, E_14>;
    whenFailure: <V_9, E_15>(apply: (e: E_15) => void) => (r: Result<V_9, E_15>) => Result<V_9, E_15>;
    combine: <V_10, E_16>(r1: Result<V_10, E_16>, r2: Result<V_10, E_16>, combineV: (v1: V_10, v2: V_10) => V_10, combineE: (e1: E_16, e2: E_16) => E_16) => Result<V_10, E_16>;
};
