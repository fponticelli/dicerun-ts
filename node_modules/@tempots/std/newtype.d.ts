/**
 * Usage:
 *
 * ```ts
 * export interface Int extends Newtype<
 *   number,
 *   { readonly Int: unique symbol }
 * > {}
 *
 * export const Int = new class extends NewtypeClass<Int> {
 *   isValid(v: number) { return Number.isInteger(v) }
 * }()
 * ```
 */
import { type Maybe } from './maybe';
export type TypeOfN<T extends Newtype<unknown, unknown>> = T['_T'];
export interface Newtype<V, S> {
    readonly _T: V;
    readonly _S: S;
}
export declare abstract class NewtypeClass<T extends Newtype<unknown, unknown>> {
    abstract isValid(v: TypeOfN<T>): boolean;
    unsafeOf(v: TypeOfN<T>): T;
    of(v: TypeOfN<T>): Maybe<T>;
    get(v: T): TypeOfN<T>;
    modify(f: (v: TypeOfN<T>) => TypeOfN<T>): (value: T) => Maybe<T>;
    unsafeModify(f: (v: TypeOfN<T>) => TypeOfN<T>): (value: T) => T;
}
