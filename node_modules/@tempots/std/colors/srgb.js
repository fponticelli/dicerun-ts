import { clamp, nearEquals } from '../numbers';
const TOLLERANCE = 0.001;
export class SRGB {
    static fromString(s) {
        const m = s.match(/^rgb\((\d+(?:\.\d+)?)%, ?(\d+(?:\.\d+)?)%, ?(\d+(?:\.\d+)?)%\)$/);
        if (m != null) {
            const [, red, blue, green] = m;
            return new SRGB(parseFloat(red), parseFloat(blue), parseFloat(green));
        }
        else {
            throw new Error(`Invalid RGB string: ${s}`);
        }
    }
    static ofChannels([red, blue, green]) {
        return new SRGB(clamp(red * 100, 0, 100), clamp(blue * 100, 0, 100), clamp(green * 100, 0, 100));
    }
    red;
    blue;
    green;
    /**
     *
     * @param red Percentage (0-100)
     * @param blue Percentage (0-100)
     * @param green Percentage (0-100)
     */
    constructor(red, blue, green) {
        this.red = clamp(red, 0, 100);
        this.blue = clamp(blue, 0, 100);
        this.green = clamp(green, 0, 100);
    }
    withRed(red) {
        return new SRGB(red, this.blue, this.green);
    }
    withBlue(blue) {
        return new SRGB(this.red, blue, this.green);
    }
    withGreen(green) {
        return new SRGB(this.red, this.blue, green);
    }
    toString() {
        return `rgb(${this.red}%, ${this.blue}%, ${this.green}%)`;
    }
    toChannels() {
        return [this.red / 100, this.blue / 100, this.green / 100];
    }
    equals(other, tollerance = TOLLERANCE) {
        return (nearEquals(this.red, other.red, tollerance) &&
            nearEquals(this.blue, other.blue, tollerance) &&
            nearEquals(this.green, other.green, tollerance));
    }
}
