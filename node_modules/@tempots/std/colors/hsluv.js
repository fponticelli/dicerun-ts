import { nearEquals } from '../numbers';
const TOLLERANCE = 0.0001;
export class HSLuv {
    static fromString(s) {
        const m = s.match(/^hsluv\((\d+)(deg)?, ?(\d+(?:\.\d+)?)%?, ?(\d+(?:\.\d+)?)%?\)$/);
        if (m != null) {
            const [, h, , s, l] = m;
            return new HSLuv(parseFloat(h), parseFloat(s), parseFloat(l));
        }
        else {
            throw new Error(`Invalid HSLuv string: ${s}`);
        }
    }
    static ofChannels([hue, saturation, lightness]) {
        return new HSLuv(hue, saturation, lightness);
    }
    hue;
    saturation;
    lightness;
    /**
     *
     * @param hue Angle in degrees (0-360)
     * @param saturation
     * @param lightness
     */
    constructor(hue, saturation, lightness) {
        this.hue = hue % 360.0;
        this.saturation = saturation;
        this.lightness = lightness;
    }
    withHue(hue) {
        return new HSLuv(hue, this.saturation, this.lightness);
    }
    withSaturation(saturation) {
        return new HSLuv(this.hue, saturation, this.lightness);
    }
    withLightness(lightness) {
        return new HSLuv(this.hue, this.saturation, lightness);
    }
    toChannels() {
        return [this.hue, this.saturation, this.lightness];
    }
    toString() {
        return `hsluv(${this.hue}deg, ${this.saturation}%, ${this.lightness}%)`;
    }
    equals(other, tollerance = TOLLERANCE) {
        if ((nearEquals(this.lightness, other.lightness, tollerance) &&
            nearEquals(this.saturation, 0, tollerance)) ||
            nearEquals(this.saturation, 100, tollerance)) {
            return true;
        }
        return (nearEquals(this.hue, other.hue, tollerance) &&
            nearEquals(this.saturation, other.saturation, tollerance) &&
            nearEquals(this.lightness, other.lightness, tollerance));
    }
}
