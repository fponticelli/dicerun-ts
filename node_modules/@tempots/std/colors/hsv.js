import { clamp, nearEquals } from '../numbers';
const TOLLERANCE = 0.0001;
export class HSV {
    static fromString(s) {
        const m = s.match(/^hsv\((\d+(?:\.\d+)?)%, ?(\d+(?:\.\d+)?)%, ?(\d+(?:\.\d+)?)%\)$/i);
        if (m != null) {
            const [, h, s, v] = m;
            return new HSV(parseFloat(h), parseFloat(s), parseFloat(v));
        }
        else {
            throw new Error(`Invalid HSV string: ${s}`);
        }
    }
    static ofChannels([hue, saturation, value]) {
        return new HSV(hue % 360.0, clamp(saturation * 100, 0, 100), clamp(value * 100, 0, 100));
    }
    hue;
    saturation;
    value;
    /**
     *
     * @param hue Angle in degrees (0-360)
     * @param saturation Percentage (0-100)
     * @param value Percentage (0-100)
     */
    constructor(hue, saturation, value) {
        this.hue = hue;
        this.saturation = saturation;
        this.value = value;
    }
    withHue(h) {
        return new HSV(h, this.saturation, this.value);
    }
    withSaturation(s) {
        return new HSV(this.hue, s, this.value);
    }
    withValue(v) {
        return new HSV(this.hue, this.saturation, v);
    }
    toChannels() {
        return [this.hue, this.saturation / 100, this.value / 100];
    }
    toString() {
        return `hsv(${this.hue}, ${this.saturation}, ${this.value})`;
    }
    equals(other, tollerance = TOLLERANCE) {
        if (nearEquals(this.value, other.value, tollerance) && (nearEquals(this.saturation, 0, tollerance) || nearEquals(this.saturation, 100, tollerance))) {
            return true;
        }
        return (nearEquals(this.hue, other.hue, tollerance) &&
            nearEquals(this.saturation, other.saturation, tollerance) &&
            nearEquals(this.value, other.value, tollerance));
    }
}
