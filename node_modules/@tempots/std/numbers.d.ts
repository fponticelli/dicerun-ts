export declare const TOLERANCE = 0.0001;
/**
  Constant value employed to see if two `number` values are very close.
**/
export declare const EPSILON = 1e-9;
/**
Returns the angular distance between 2 angles.
**/
export declare function angleDifference(a: number, b: number, turn?: number): number;
/**
Rounds a number up to the specified number of decimals.
**/
export declare function ceilTo(v: number, decimals: number): number;
/**
`clamp` restricts a value within the specified range.
```ts
log(clamp(1.3, 0, 1)) // prints 1
log(clamp(0.8, 0, 1)) // prints 0.8
log(clamp(-0.5, 0, 1)) // prints 0.0
```
**/
export declare function clamp(value: number, min: number, max: number): number;
export declare function clampInt(value: number, min: number, max: number): number;
/**
Like clamp but you only pass one argument (`max`) that is used as the upper limit
and the opposite (additive inverse or `-max`) as the lower limit.
**/
export declare function clampSym(v: number, max: number): number;
/**
It returns the comparison value (an integer number) between two `float` values.
**/
export declare function compare(a: number, b: number): number;
/**
Rounds a number down to the specified number of decimals.
**/
export declare function floorTo(v: number, decimals: number): number;
/**
`normalize` clamps the passwed value between 0 and 1.
**/
export declare function normalize(value: number): number;
export declare function toHex(num: number, length?: number): string;
/**
`interpolate` returns a value between `a` and `b` for any value of `t` (normally between 0 and 1).
**/
export declare function interpolate(a: number, b: number, t: number): number;
/**
Interpolates values in a polar coordinate system looking for the narrowest delta angle.
It can be either clock-wise or counter-clock-wise.
**/
export declare function interpolateAngle(a: number, b: number, t: number, turn?: number): number;
/**
Interpolates values in a polar coordinate system looking for the wideset delta angle.
It can be either clock-wise or counter-clock-wise.
**/
export declare function interpolateAngleWidest(a: number, b: number, t: number, turn?: number): number;
/**
Interpolates values in a polar coordinate system always in clock-wise direction.
**/
export declare function interpolateAngleCW(a: number, b: number, t: number, turn?: number): number;
/**
Interpolates values in a polar coordinate system always in counter-clock-wise direction.
**/
export declare function interpolateAngleCCW(a: number, b: number, t: number, turn?: number): number;
/**
number numbers can sometime introduce tiny errors even for simple operations.
`nearEquals` compares two floats using a tiny tollerance (last optional
argument). By default it is defined as `EPSILON`.
**/
export declare function nearEquals(a: number, b: number, tollerance?: number): boolean;
/**
number numbers can sometime introduce tiny errors even for simple operations.
`nearEqualAngles` compares two angles (default is 360deg) using a tiny
tollerance (last optional argument). By default the tollerance is defined as
`EPSILON`.
**/
export declare function nearEqualAngles(a: number, b: number, turn?: number, tollerance?: number): boolean;
/**
`nearZero` finds if the passed number is zero or very close to it. By default
`EPSILON` is used as the tollerance value.
**/
export declare function nearZero(n: number, tollerance?: number): boolean;
/**
Computes the nth root (`index`) of `base`.
**/
export declare function root(base: number, index: number): number;
/**
Rounds a number to the specified number of decimals.
**/
export declare function roundTo(f: number, decimals: number): number;
/**
`sign` returns `-1` if `value` is a negative number, `1` otherwise.
*/
export declare function sign<T extends number>(value: T): number;
/**
Passed two boundaries values (`min`, `max`), `wrap` ensures that the passed value `v` will
be included in the boundaries. If the value exceeds `max`, the value is reduced by `min`
repeatedely until it falls within the range. Similar and inverted treatment is performed if
the value is below `min`.
**/
export declare function wrap(v: number, min: number, max: number): number;
/**
Similar to `wrap`, it works for numbers between 0 and `max`.
**/
export declare function wrapCircular(v: number, max: number): number;
