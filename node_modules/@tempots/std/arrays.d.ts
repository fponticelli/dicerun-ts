/**
 * Utility functions to manipulate `Array` values.
 */
import { Maybe } from './maybe';
import { type Ordering, type Compare } from './ord';
import { type Primitive } from './types/utility';
export declare function map<A, B>(arr: A[], f: (a: A, index: number) => B): B[];
export declare function mapNotNull<A, B>(arr: A[], f: (a: A, index: number) => B | null | undefined): B[];
export declare function flatMap<A, B>(arr: A[], f: (a: A) => B[]): B[];
export declare function head<A>(arr: A[]): Maybe<A>;
export declare function tail<A>(arr: A[]): A[];
export declare function equals<T>(a: T[], b: T[], equality: (a: T, b: T) => boolean): boolean;
export declare function makeEquals<T>(equality: (a: T, b: T) => boolean): (a: T[], b: T[]) => boolean;
export declare function isEmpty<T>(arr: T[]): arr is [];
export declare function hasValues<T>(arr: T[]): arr is [T, ...T[]];
export declare function filter<T>(arr: T[], predicate: (v: T) => boolean): T[];
export declare function filterNulls<T>(arr: Array<T | null | undefined>): T[];
export declare function flatten<T>(arr: T[][]): T[];
export declare function foldLeft<T, B>(arr: T[], f: (acc: B, curr: T) => B, b: B): B;
export declare function all<T>(arr: T[], predicate: (v: T) => boolean): boolean;
export declare function any<T>(arr: T[], predicate: (v: T) => boolean): boolean;
export declare function each<T>(arr: T[], f: (v: T) => void): void;
export declare function concat<A>(...arrs: A[][]): A[];
export declare function makeCompare<A>(comparef: Compare<A>, shorterFirst?: boolean): (a: A[], b: A[]) => number;
export declare function sort<A>(compare: (a: A, b: A) => Ordering, arr: A[]): A[];
export declare function range<A>(length: number, f: (index: number) => A): A[];
export declare function numbersRange(length: number, startAt?: number): number[];
export declare function fill<A>(length: number, value: A): A[];
export declare function distinctPrimitive<T extends Primitive>(values: T[]): T[];
export declare function distinctByPredicate<T>(values: T[], predicate: (a: T) => string): T[];
export declare function remove<A>(arr: A[], item: A, predicate?: (a: A) => boolean): boolean;
export declare function ofIterableIterator<A>(it: IterableIterator<A>): A[];
export interface DiffOperations<T> {
    removals: Array<{
        at: number;
        qt: number;
    }>;
    swaps: Array<{
        from: number;
        to: number;
    }>;
    inserts: Array<{
        at: number;
        values: T[];
    }>;
}
export declare function diffOperations<T, K>(from: T[], to: T[], getKey: (v: T) => K): DiffOperations<T>;
export declare function applyOperations<T>(operations: DiffOperations<T>, start: T[]): T[];
export declare function joinWithConjunction<A>(arr: A[], conjunction?: string, separator?: string): string;
