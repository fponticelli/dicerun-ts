import { type Differentiate, type DifferentiateAt } from './types/differentiate';
import { type AnyKey } from './types/utility';
import { type ObjectWithField, type ObjectWithPath, type TypeAtPath } from './types/objects';
export declare function matchLiteral<A extends AnyKey, B>(input: A, matcher: {
    [k in A]: B;
}): B;
export declare function match<F extends AnyKey, T extends ObjectWithField<F, any>, B>(input: T, field: F, matcher: {
    [k in T[F]]: (arg: Differentiate<F, T, k>) => B;
}): B;
export declare function deepMatch<Path extends AnyKey[], T extends ObjectWithPath<Path, any>, B>(input: T, path: Path, matcher: {
    [k in TypeAtPath<Path, T>]: (arg: DifferentiateAt<Path, T, k>) => B;
}): B;
export declare function createMatch<F extends AnyKey>(field: F): <T extends ObjectWithField<F, any>, B>(input: T, matcher: { [k in T[F]]: (arg: Differentiate<F, T, k>) => B; }) => B;
export declare const createDeepMatch: <Path extends AnyKey[]>(...path: Path) => <T extends ObjectWithPath<Path, any>, B>(input: T, matcher: { [k in TypeAtPath<Path, T>]: (arg: DifferentiateAt<Path, T, k>) => B; }) => B;
export declare const matchKind: <T extends ObjectWithField<"kind", any>, B>(input: T, matcher: { [k in T["kind"]]: (arg: Differentiate<"kind", T, k>) => B; }) => B;
export declare const matchType: <T extends ObjectWithField<"type", any>, B>(input: T, matcher: { [k in T["type"]]: (arg: Differentiate<"type", T, k>) => B; }) => B;
