export interface Idle {
    type: 'idle';
}
export interface Loading {
    type: 'loading';
}
export interface Success<V> {
    type: 'success';
    value: V;
}
export interface Failure<E> {
    type: 'failure';
    error: E;
}
export type AsyncResult<V, E> = Idle | Loading | Success<V> | Failure<E>;
export declare const AsyncResult: {
    idle: {
        type: "idle";
    };
    loading: {
        type: "loading";
    };
    success<V>(value: V): AsyncResult<V, never>;
    failure<E>(error: E): AsyncResult<never, E>;
    isSuccess<V_1, E_1>(r: AsyncResult<V_1, E_1>): r is Success<V_1>;
    isFailure<V_2, E_2>(r: AsyncResult<V_2, E_2>): r is Failure<E_2>;
    isIdle<V_3, E_3>(r: AsyncResult<V_3, E_3>): r is Idle;
    isLoading<V_4, E_4>(r: AsyncResult<V_4, E_4>): r is Loading;
    getOrElse<V_5, E_5>(r: AsyncResult<V_5, E_5>, alt: V_5): V_5;
    getOrElseLazy<V_6, E_6>(r: AsyncResult<V_6, E_6>, altf: () => V_6): V_6;
    getOrNull<V_7, E_7>(r: AsyncResult<V_7, E_7>): V_7 | null;
    getOrUndefined<V_8, E_8>(r: AsyncResult<V_8, E_8>): V_8 | undefined;
    cmatch: <V1, V2, E_9>(success: (value: V1) => V2, failure: (error: E_9) => V2, loading: () => V2, idle?: () => V2) => (r: AsyncResult<V1, E_9>) => V2;
    match: <V1_1, V2_1, E_10>(r: AsyncResult<V1_1, E_10>, success: (value: V1_1) => V2_1, failure: (error: E_10) => V2_1, loading: () => V2_1, idle?: () => V2_1) => V2_1;
    whenSuccess: <V_9, E_11>(apply: (v: V_9) => void) => (r: AsyncResult<V_9, E_11>) => AsyncResult<V_9, E_11>;
    whenFailure: <V_10, E_12>(apply: (e: E_12) => void) => (r: AsyncResult<V_10, E_12>) => AsyncResult<V_10, E_12>;
};
