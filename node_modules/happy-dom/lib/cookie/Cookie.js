"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CookiePairRegex = /([^=]+)(?:=([\s\S]*))?/;
/**
 * Cookie.
 */
class Cookie {
    /**
     * Constructor.
     *
     * @param cookie Cookie.
     */
    constructor(cookie) {
        this.pairs = {};
        //
        this.key = '';
        this.value = '';
        this.size = 0;
        // Optional
        this.domain = '';
        this.path = '';
        this.expriesOrMaxAge = null;
        this.httpOnly = false;
        this.secure = false;
        this.sameSite = '';
        let match;
        const parts = cookie.split(';').filter(Boolean);
        // Part[0] is the key-value pair.
        match = new RegExp(CookiePairRegex).exec(parts[0]);
        if (!match) {
            throw new Error(`Invalid cookie: ${cookie}`);
        }
        this.key = match[1].trim();
        this.value = match[2];
        // Set key is empty if match[2] is undefined.
        if (!match[2] && parts[0][this.key.length] !== '=') {
            this.value = this.key;
            this.key = '';
        }
        this.pairs[this.key] = this.value;
        this.size = this.key.length + this.value.length;
        // Attribute.
        for (const part of parts.slice(1)) {
            match = new RegExp(CookiePairRegex).exec(part);
            if (!match) {
                throw new Error(`Invalid cookie: ${part}`);
            }
            const key = match[1].trim();
            const value = match[2];
            switch (key.toLowerCase()) {
                case 'expires':
                    this.expriesOrMaxAge = new Date(value);
                    break;
                case 'max-age':
                    this.expriesOrMaxAge = new Date(parseInt(value, 10) * 1000 + Date.now());
                    break;
                case 'domain':
                    this.domain = value;
                    break;
                case 'path':
                    this.path = value.startsWith('/') ? value : `/${value}`;
                    break;
                case 'httponly':
                    this.httpOnly = true;
                    break;
                case 'secure':
                    this.secure = true;
                    break;
                case 'samesite':
                    this.sameSite = value;
                    break;
                default:
                    continue; // Skip.
            }
            // Skip unknown key-value pair.
            if (['expires', 'max-age', 'domain', 'path', 'httponly', 'secure', 'samesite'].indexOf(key.toLowerCase()) === -1) {
                continue;
            }
            this.pairs[key] = value;
        }
    }
    /**
     * Returns a raw string of the cookie.
     */
    rawString() {
        return Object.keys(this.pairs)
            .map((key) => {
            if (key) {
                return `${key}=${this.pairs[key]}`;
            }
            return this.pairs[key];
        })
            .join('; ');
    }
    /**
     *
     */
    cookieString() {
        if (this.key) {
            return `${this.key}=${this.value}`;
        }
        return this.value;
    }
    /**
     *
     */
    isExpired() {
        // If the expries/maxage is set, then determine whether it is expired.
        if (this.expriesOrMaxAge && this.expriesOrMaxAge.getTime() < Date.now()) {
            return true;
        }
        // If the expries/maxage is not set, it's a session-level cookie that will expire when the browser is closed.
        // (it's never expired in happy-dom)
        return false;
    }
    /**
     *
     */
    isHttpOnly() {
        return this.httpOnly;
    }
    /**
     *
     */
    isSecure() {
        return this.secure;
    }
    /**
     * Parse a cookie string.
     *
     * @param cookieString
     */
    static parse(cookieString) {
        return new Cookie(cookieString);
    }
    /**
     * Stringify a Cookie object.
     *
     * @param cookie
     */
    static stringify(cookie) {
        return cookie.toString();
    }
}
exports.default = Cookie;
//# sourceMappingURL=Cookie.js.map