"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const NodeTypeEnum_1 = __importDefault(require("../node/NodeTypeEnum"));
const NAMED_ITEM_ATTRIBUTES = ['id', 'name'];
/**
 * Element utility.
 */
class ElementUtility {
    /**
     * Handles appending a child element to the "children" property.
     *
     * @param parentElement Parent element.
     * @param node Node.
     */
    static appendChild(parentElement, node) {
        if (node.nodeType === NodeTypeEnum_1.default.elementNode && node !== parentElement) {
            if (node.parentNode && node.parentNode.children) {
                const index = node.parentNode.children.indexOf(node);
                if (index !== -1) {
                    for (const attribute of NAMED_ITEM_ATTRIBUTES) {
                        if (node._attributes[attribute]) {
                            node.parentNode.children._removeNamedItem(node, node._attributes[attribute].value);
                        }
                    }
                    node.parentNode.children.splice(index, 1);
                }
            }
            for (const attribute of NAMED_ITEM_ATTRIBUTES) {
                if (node._attributes[attribute]) {
                    parentElement.children._appendNamedItem(node, node._attributes[attribute].value);
                }
            }
            parentElement.children.push(node);
        }
    }
    /**
     * Handles removing a child element from the "children" property.
     *
     * @param parentElement Parent element.
     * @param node Node.
     */
    static removeChild(parentElement, node) {
        if (node.nodeType === NodeTypeEnum_1.default.elementNode) {
            const index = parentElement.children.indexOf(node);
            if (index !== -1) {
                for (const attribute of NAMED_ITEM_ATTRIBUTES) {
                    if (node._attributes[attribute]) {
                        parentElement.children._removeNamedItem(node, node._attributes[attribute].value);
                    }
                }
                parentElement.children.splice(index, 1);
            }
        }
    }
    /**
     *
     * Handles inserting a child element to the "children" property.
     *
     * @param parentElement Parent element.
     * @param newNode
     * @param referenceNode
     */
    static insertBefore(parentElement, newNode, referenceNode) {
        if (newNode.nodeType === NodeTypeEnum_1.default.elementNode) {
            if (newNode.parentNode && newNode.parentNode.children) {
                const index = newNode.parentNode.children.indexOf(newNode);
                if (index !== -1) {
                    for (const attribute of NAMED_ITEM_ATTRIBUTES) {
                        if (newNode._attributes[attribute]) {
                            (newNode.parentNode.children)._removeNamedItem(newNode, newNode._attributes[attribute].value);
                        }
                    }
                    newNode.parentNode.children.splice(index, 1);
                }
            }
            // Node.ts will call appendChild() for the scenario where "referenceNode" is "null"
            if (referenceNode) {
                if (referenceNode.nodeType === NodeTypeEnum_1.default.elementNode) {
                    const index = parentElement.children.indexOf(referenceNode);
                    if (index !== -1) {
                        parentElement.children.splice(index, 0, newNode);
                    }
                }
                else {
                    for (const node of parentElement.childNodes) {
                        if (node === referenceNode) {
                            parentElement.children.push(newNode);
                        }
                        if (node.nodeType === NodeTypeEnum_1.default.elementNode) {
                            parentElement.children.push(node);
                        }
                    }
                }
            }
            if (referenceNode || referenceNode === null) {
                for (const attribute of NAMED_ITEM_ATTRIBUTES) {
                    if (newNode._attributes[attribute]) {
                        parentElement.children._appendNamedItem(newNode, newNode._attributes[attribute].value);
                    }
                }
            }
        }
    }
}
exports.default = ElementUtility;
//# sourceMappingURL=ElementUtility.js.map