"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Node_1 = __importDefault(require("../nodes/node/Node"));
const SelectorItem_1 = __importDefault(require("./SelectorItem"));
const NodeList_1 = __importDefault(require("../nodes/node/NodeList"));
const SELECTOR_PART_REGEXP = /(\[[^\]]+\]|[a-zA-Z0-9-_.#"*:()\]]+)|([ ,>]+)/g;
/**
 * Utility for query selection in an HTML element.
 *
 * @class QuerySelector
 */
class QuerySelector {
    /**
     * Finds elements based on a query selector.
     *
     * @param node Node to search in.
     * @param selector Selector.
     * @returns HTML elements.
     */
    static querySelectorAll(node, selector) {
        const matches = new NodeList_1.default();
        if (selector === '') {
            throw new Error("Failed to execute 'querySelectorAll' on 'Element': The provided selector is empty.");
        }
        if (selector === null || selector === undefined) {
            return matches;
        }
        for (const parts of this.getSelectorParts(selector)) {
            for (const element of this.findAll(node, [node], parts)) {
                if (!matches.includes(element)) {
                    matches.push(element);
                }
            }
        }
        return matches;
    }
    /**
     * Finds an element based on a query selector.
     *
     * @param node Node to search in.
     * @param selector Selector.
     * @returns HTML element.
     */
    static querySelector(node, selector) {
        if (selector === '') {
            throw new Error("Failed to execute 'querySelector' on 'Element': The provided selector is empty.");
        }
        if (selector === null || selector === undefined) {
            return null;
        }
        for (const parts of this.getSelectorParts(selector)) {
            const match = this.findFirst(node, [node], parts);
            if (match) {
                return match;
            }
        }
        return null;
    }
    /**
     * Checks if a node matches a selector and returns priority weight.
     *
     * @param node Node to search in.
     * @param selector Selector.
     * @returns Result.
     */
    static match(node, selector) {
        for (const parts of this.getSelectorParts(selector)) {
            const result = this.matchesSelector(node, node, parts.reverse());
            if (result.matches) {
                return result;
            }
        }
        return { priorityWeight: 0, matches: false };
    }
    /**
     * Checks if a node matches a selector.
     *
     * @param targetNode Target node.
     * @param currentNode Current node.
     * @param selectorParts Selector parts.
     * @param [priorityWeight] Priority weight.
     * @returns Result.
     */
    static matchesSelector(targetNode, currentNode, selectorParts, priorityWeight = 0) {
        const isDirectChild = selectorParts[0] === '>';
        if (isDirectChild) {
            selectorParts = selectorParts.slice(1);
            if (selectorParts.length === 0) {
                return { priorityWeight: 0, matches: false };
            }
        }
        if (selectorParts.length === 0) {
            return { priorityWeight, matches: true };
        }
        const selector = new SelectorItem_1.default(selectorParts[0]);
        const result = selector.match(currentNode);
        if (result.matches && selectorParts.length === 1) {
            return {
                priorityWeight: priorityWeight + result.priorityWeight,
                matches: true
            };
        }
        if (!currentNode.parentElement || (targetNode === currentNode && !result.matches)) {
            return { priorityWeight: 0, matches: false };
        }
        return this.matchesSelector(isDirectChild ? currentNode.parentElement : targetNode, currentNode.parentElement, result.matches ? selectorParts.slice(1) : selectorParts, priorityWeight + result.priorityWeight);
    }
    /**
     * Finds elements based on a query selector for a part of a list of selectors separated with comma.
     *
     * @param rootNode Root node.
     * @param nodes Nodes.
     * @param selectorParts Selector parts.
     * @param [selectorItem] Selector item.
     * @returns HTML elements.
     */
    static findAll(rootNode, nodes, selectorParts, selectorItem) {
        const isDirectChild = selectorParts[0] === '>';
        if (isDirectChild) {
            selectorParts = selectorParts.slice(1);
        }
        const selector = selectorItem || new SelectorItem_1.default(selectorParts[0]);
        let matched = [];
        for (const node of nodes) {
            if (node.nodeType === Node_1.default.ELEMENT_NODE) {
                if (selector.match(node).matches) {
                    if (selectorParts.length === 1) {
                        if (rootNode !== node) {
                            matched.push(node);
                        }
                    }
                    else {
                        matched = matched.concat(this.findAll(rootNode, node.children, selectorParts.slice(1), null));
                    }
                }
            }
            if (!isDirectChild && node['children']) {
                matched = matched.concat(this.findAll(rootNode, node['children'], selectorParts, selector));
            }
        }
        return matched;
    }
    /**
     * Finds an element based on a query selector for a part of a list of selectors separated with comma.
     *
     * @param rootNode
     * @param nodes Nodes.
     * @param selector Selector.
     * @param selectorParts
     * @param [selectorItem] Selector item.
     * @returns HTML element.
     */
    static findFirst(rootNode, nodes, selectorParts, selectorItem) {
        const isDirectChild = selectorParts[0] === '>';
        if (isDirectChild) {
            selectorParts = selectorParts.slice(1);
        }
        const selector = selectorItem || new SelectorItem_1.default(selectorParts[0]);
        for (const node of nodes) {
            if (node.nodeType === Node_1.default.ELEMENT_NODE && selector.match(node).matches) {
                if (selectorParts.length === 1) {
                    if (rootNode !== node) {
                        return node;
                    }
                }
                else {
                    const childSelector = this.findFirst(rootNode, node.children, selectorParts.slice(1), null);
                    if (childSelector) {
                        return childSelector;
                    }
                }
            }
            if (!isDirectChild && node['children']) {
                const childSelector = this.findFirst(rootNode, node['children'], selectorParts, selector);
                if (childSelector) {
                    return childSelector;
                }
            }
        }
        return null;
    }
    /**
     * Splits a selector string into groups and parts.
     *
     * @param selector Selector.
     * @returns HTML element.
     */
    static getSelectorParts(selector) {
        if (selector === '*' || (!selector.includes(',') && !selector.includes(' '))) {
            return [[selector]];
        }
        const regexp = new RegExp(SELECTOR_PART_REGEXP);
        const groups = [];
        let currentSelector = '';
        let parts = [];
        let match;
        while ((match = regexp.exec(selector))) {
            if (match[2]) {
                const trimmed = match[2].trim();
                parts.push(currentSelector);
                currentSelector = '';
                if (trimmed === ',') {
                    groups.push(parts);
                    parts = [];
                }
                else if (trimmed === '>') {
                    parts.push('>');
                }
            }
            else if (match[1]) {
                currentSelector += match[1];
            }
        }
        if (currentSelector !== '') {
            parts.push(currentSelector);
        }
        if (parts.length > 0) {
            groups.push(parts);
        }
        return groups;
    }
}
exports.default = QuerySelector;
//# sourceMappingURL=QuerySelector.js.map