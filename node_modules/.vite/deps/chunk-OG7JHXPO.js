import {
  __publicField
} from "./chunk-IVLCYF2H.js";

// node_modules/@tempots/dom/prop.js
var $isSignal = Symbol("isSignal");
var $isProp = Symbol("isProp");
var _a;
var _Signal = class {
  constructor(_value) {
    __publicField(this, "_value");
    __publicField(this, _a, true);
    __publicField(this, "_listeners", []);
    __publicField(this, "get", () => {
      return this._value;
    });
    __publicField(this, "subscribe", (listener) => {
      this._listeners.push(listener);
      return () => {
        const index = this._listeners.indexOf(listener);
        if (index >= 0) {
          this._listeners.splice(index, 1);
        }
      };
    });
    __publicField(this, "map", (f) => {
      const prop = new Prop(f(this._value));
      this.subscribe((value) => {
        prop.set(f(value));
      });
      return prop;
    });
    __publicField(this, "flatMap", (f) => {
      let signal = f(this._value);
      const prop = new Prop(signal.get());
      this.subscribe((value) => {
        signal.clean();
        signal = f(value);
        signal.subscribe((value2) => {
          prop.set(value2);
        });
      });
      return prop;
    });
    __publicField(this, "tap", (f) => {
      f(this._value);
      this.subscribe(f);
      return this;
    });
    __publicField(this, "at", (key) => {
      return this.map((value) => value[key]);
    });
    __publicField(this, "filter", (predicate) => {
      const prop = new Prop(this._value);
      this.subscribe((value) => {
        if (predicate(value)) {
          prop.set(value);
        }
      });
      return prop;
    });
    __publicField(this, "distinct", (equality) => {
      let lastValue = this._value;
      return this.filter((value) => {
        const result = !equality(value, lastValue);
        lastValue = value;
        return result;
      });
    });
    __publicField(this, "mapAsync", (f, alt) => {
      let counter = 0;
      const prop = new Prop(alt);
      f(this._value).then((value) => {
        if (counter === 0)
          prop.set(value);
      }).catch((e) => {
        throw e;
      });
      this.subscribe((value) => {
        const matchCounter = ++counter;
        f(value).then((value2) => {
          if (matchCounter === counter) {
            prop.set(value2);
          }
        }).catch((e) => {
          throw e;
        });
      });
      return prop;
    });
    __publicField(this, "mapMaybe", (f, alt) => {
      const prop = new Prop(f(this._value) ?? alt);
      this.subscribe((value) => {
        const newValue = f(value);
        if (newValue != null)
          prop.set(newValue);
      });
      return prop;
    });
    __publicField(this, "combine", (other, f) => {
      const prop = new Prop(f(this._value, other.get()));
      this.subscribe((value) => {
        prop.set(f(value, other.get()));
      });
      other.subscribe((value) => {
        prop.set(f(this._value, value));
      });
      return prop;
    });
    __publicField(this, "feed", (prop) => {
      this.subscribe((value) => {
        prop.set(value);
      });
      return prop;
    });
    __publicField(this, "deriveProp", () => {
      return new Prop(this._value);
    });
    __publicField(this, "clean", () => {
      this._listeners.length = 0;
    });
    this._value = _value;
  }
  static of(value) {
    return new _Signal(value);
  }
  static ofValue(value) {
    return value == null ? void 0 : _Signal.wrap(value);
  }
  static wrap(value) {
    return _Signal.isSignal(value) ? value : new _Signal(value);
  }
  static isSignal(x) {
    const s = x;
    return s != null && typeof s.get === "function" && typeof s.subscribe === "function";
  }
  /**
   * Combines many into one using a merging function
   */
  static combine(others, f) {
    function getValues(others2) {
      return others2.map((other) => other.get());
    }
    const prop = new Prop(f(...getValues(others)));
    others.forEach((other) => {
      other.subscribe(() => {
        prop.set(f(...getValues(others)));
      });
    });
    return prop;
  }
};
var Signal = _Signal;
_a = $isSignal;
var _a2;
var _Prop = class extends Signal {
  constructor() {
    super(...arguments);
    __publicField(this, _a2, true);
    __publicField(this, "set", (value) => {
      if (this._value === value)
        return;
      this._value = value;
      this._listeners.forEach((listener) => {
        listener(value);
      });
    });
    __publicField(this, "update", (f) => {
      this.set(f(this._value));
    });
    __publicField(this, "atLens", (key) => {
      return this.iso((value) => value[key], (value) => ({ ...this._value, [key]: value }));
    });
    __publicField(this, "reducer", (f) => {
      return (action) => {
        this.set(f(this._value, action));
      };
    });
    __publicField(this, "iso", (map, reverse) => {
      const prop = new _Prop(map(this._value));
      this.subscribe((value) => {
        prop.set(map(value));
      });
      prop.subscribe((value) => {
        this.set(reverse(value));
      });
      return prop;
    });
  }
  static isProp(x) {
    const p = x;
    return Signal.isSignal(x) && typeof p.set === "function";
  }
  static of(value) {
    return new _Prop(value);
  }
};
var Prop = _Prop;
_a2 = $isProp;

// node_modules/@tempots/dom/components/Text.js
function subscribeToSignal(prop, listener, clear) {
  const unsubscribe = prop.subscribe(listener);
  return (removeTree) => {
    unsubscribe();
    clear(removeTree);
  };
}
var TextImpl = class {
  constructor(text) {
    __publicField(this, "text");
    __publicField(this, "appendTo", (ctx) => {
      const [set, clear] = ctx.createText(this.text.get());
      return subscribeToSignal(this.text, set, clear);
    });
    this.text = text;
  }
};
function propFromChildren(children) {
  if (children instanceof Signal) {
    return children.map((child) => {
      if (child == null) {
        return "";
      }
      return String(child);
    });
  }
  return new Signal(String(children));
}
function Text({ children }) {
  const prop = propFromChildren(children);
  return new TextImpl(prop);
}

// node_modules/@tempots/dom/components/Attribute.js
var AttributeImpl = class {
  constructor(name, value) {
    __publicField(this, "name");
    __publicField(this, "value");
    __publicField(this, "appendTo", (ctx) => {
      const [set, clear] = ctx.createAttribute(this.name, this.value.get());
      return subscribeToSignal(this.value, set, clear);
    });
    this.name = name;
    this.value = value;
  }
};
function Attribute({ name, value }) {
  return new AttributeImpl(name, value);
}

// node_modules/@tempots/dom/components/BooleanAttribute.js
var BooleanAttributeImpl = class {
  constructor(name, value) {
    __publicField(this, "name");
    __publicField(this, "value");
    __publicField(this, "appendTo", (ctx) => {
      const [set, clear] = ctx.createBooleanAttribute(this.name, this.value.get());
      return subscribeToSignal(this.value, set, clear);
    });
    this.name = name;
    this.value = value;
  }
};
function BooleanAttribute({ name, value }) {
  return new BooleanAttributeImpl(name, value);
}

// node_modules/@tempots/dom/components/Property.js
var PropertyImpl = class {
  constructor(name, value) {
    __publicField(this, "name");
    __publicField(this, "value");
    __publicField(this, "appendTo", (ctx) => {
      const [set, clear] = ctx.createProperty(this.name, this.value.get());
      return subscribeToSignal(this.value, set, clear);
    });
    this.name = name;
    this.value = value;
  }
};
function Property({ name, value }) {
  return new PropertyImpl(name, value);
}

// node_modules/@tempots/dom/components/ClassName.js
var ClassNameImpl = class {
  constructor(cls) {
    __publicField(this, "cls");
    __publicField(this, "appendTo", (ctx) => {
      const [set, clear] = ctx.createClass(this.cls.get() ?? "");
      return subscribeToSignal(this.cls.map((v) => v ?? ""), set, clear);
    });
    this.cls = cls;
  }
};
function ClassName({ value }) {
  return new ClassNameImpl(value);
}

// node_modules/@tempots/dom/components/On.js
var OnImpl = class {
  constructor(name, handler) {
    __publicField(this, "name");
    __publicField(this, "handler");
    __publicField(this, "appendTo", (ctx) => {
      return ctx.createHandler(this.name, this.handler);
    });
    this.name = name;
    this.handler = handler;
  }
};
function On({ name, handler }) {
  return new OnImpl(name, handler);
}

// node_modules/@tempots/dom/components/Fragment.js
var FragmentImpl = class {
  constructor(children) {
    __publicField(this, "children");
    __publicField(this, "appendTo", (ctx) => {
      const clears = this.children.map((child) => child.appendTo(ctx));
      return (removeTree) => {
        clears.forEach((clear) => {
          clear(removeTree);
        });
      };
    });
    this.children = children;
  }
};
function Fragment({ children }) {
  return new FragmentImpl(makeRenderables(children));
}

// node_modules/@tempots/dom/jsx-runtime.js
var domBooleanAttributes = /* @__PURE__ */ new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "capture",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablepictureinpicture",
  "disableremoteplayback",
  "download",
  "draggable",
  "formnovalidate",
  "hidden",
  "ismap",
  "itemscope",
  "loop",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  "spellcheck",
  "truespeed"
]);
var domProperties = /* @__PURE__ */ new Set([
  "checked",
  "checked",
  "classList",
  "className",
  "contentEditable",
  "dataset",
  "innerHTML",
  "multiple",
  "muted",
  "scrollLeft",
  "scrollTop",
  "selected",
  "style",
  "tabIndex",
  "textContent",
  "value"
]);
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "bigint" || value instanceof Date;
}
function makeRenderables(value) {
  if (value == null) {
    return [];
  }
  if (Array.isArray(value)) {
    return value.flatMap(makeRenderables);
  }
  if (typeof value === "string") {
    return [new TextImpl(new Prop(value))];
  }
  if (Signal.isSignal(value)) {
    return [new TextImpl(value)];
  }
  if (typeof value === "object" && "appendTo" in value) {
    return [value];
  }
  if (isPrimitive(value)) {
    return [new TextImpl(new Prop(value).map(String))];
  }
  throw new Error(`Unkwown renderable: ${String(value)}`);
}
function makeRenderable(value) {
  const renderables = makeRenderables(value);
  if (renderables.length === 0) {
    return new FragmentImpl([]);
  }
  if (renderables.length === 1) {
    return renderables[0];
  }
  return new FragmentImpl(renderables);
}
function isNamedConstructor(obj) {
  var _a3, _b;
  return ((_b = (_a3 = obj.prototype) == null ? void 0 : _a3.constructor) == null ? void 0 : _b.name) != null;
}
function makeFragment({ children }) {
  if (Array.isArray(children)) {
    return new FragmentImpl(children.flatMap(makeRenderables));
  } else {
    return makeRenderable(children);
  }
}
function makeElement(Name, ...args) {
  if (typeof Name === "function") {
    if (isNamedConstructor(Name)) {
      const el = new Name(...args);
      return el;
    } else {
      const el = Name(...args);
      return el;
    }
  }
  const { children: untypedChildren, ...rest } = args[0] ?? {};
  const children = [];
  if (Array.isArray(untypedChildren)) {
    children.push(...untypedChildren.flatMap(makeRenderables));
  } else if (untypedChildren !== void 0) {
    children.push(...makeRenderables(untypedChildren));
  }
  for (const [key, value] of Object.entries(rest)) {
    if (key.startsWith("on")) {
      const eventName = key.slice(2).toLowerCase();
      children.push(new OnImpl(eventName, value));
      continue;
    }
    if (value == null) {
      continue;
    }
    const prop = isPrimitive(value) ? new Prop(value) : value;
    if (key === "class" || key === "className") {
      children.push(new ClassNameImpl(prop));
      continue;
    }
    if (domProperties.has(key)) {
      children.push(new PropertyImpl(key, prop));
      continue;
    }
    if (domBooleanAttributes.has(key)) {
      children.push(new BooleanAttributeImpl(key, prop));
      continue;
    }
    children.push(new AttributeImpl(key, prop));
  }
  return new ElImpl(Name, children);
}

// node_modules/@tempots/dom/components/El.js
var ElImpl = class {
  constructor(tagName, children) {
    __publicField(this, "tagName");
    __publicField(this, "children");
    __publicField(this, "appendTo", (ctx) => {
      const newCtx = ctx.makeElement(this.tagName);
      const clears = this.children.map((child) => child.appendTo(newCtx));
      return (removeTree) => {
        newCtx.requestClear(removeTree, () => {
          clears.forEach((clear) => {
            clear(false);
          });
        });
      };
    });
    this.tagName = tagName;
    this.children = children;
  }
};
function El({ tagName, children }) {
  return new ElImpl(tagName, makeRenderables(children));
}

export {
  Signal,
  Prop,
  ElImpl,
  El,
  TextImpl,
  Text,
  AttributeImpl,
  Attribute,
  BooleanAttributeImpl,
  BooleanAttribute,
  PropertyImpl,
  Property,
  ClassNameImpl,
  ClassName,
  OnImpl,
  On,
  FragmentImpl,
  Fragment,
  makeRenderables,
  makeRenderable,
  makeFragment,
  makeElement
};
//# sourceMappingURL=chunk-OG7JHXPO.js.map
