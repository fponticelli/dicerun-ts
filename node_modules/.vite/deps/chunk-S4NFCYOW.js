import {
  Fragment,
  FragmentImpl,
  Prop,
  makeElement,
  makeFragment,
  makeRenderable
} from "./chunk-OG7JHXPO.js";
import {
  __publicField
} from "./chunk-IVLCYF2H.js";

// node_modules/@tempots/dom/dom-context.js
function extractClassNames(cls) {
  return (cls ?? "").split(/\s+/g).filter((className) => className.length > 0);
}
function createIntegerSet(x) {
  const integerSet = /* @__PURE__ */ new Set();
  for (let i = 0; i < x; i++) {
    integerSet.add(i);
  }
  return integerSet;
}
function makeProviderMark() {
  return Symbol("providerMark");
}
var DOMContext = class {
  constructor(document, element, reference, ns, providers) {
    __publicField(this, "document");
    __publicField(this, "element");
    __publicField(this, "reference");
    __publicField(this, "ns");
    __publicField(this, "providers");
    __publicField(this, "suspendedClears", []);
    this.document = document;
    this.element = element;
    this.reference = reference;
    this.ns = ns;
    this.providers = providers;
  }
  static of(element) {
    return new DOMContext(element.ownerDocument, element, void 0, void 0, {});
  }
  append(node) {
    if (this.reference !== void 0) {
      try {
        this.element.insertBefore(node, this.reference);
      } catch (_) {
        this.element.appendChild(node);
      }
    } else {
      this.element.appendChild(node);
    }
  }
  getElement() {
    return this.element;
  }
  getDocument() {
    return this.document;
  }
  makeReference() {
    const textNode = this.document.createTextNode("");
    this.append(textNode);
    return new DOMContext(this.document, this.element, textNode, this.ns, this.providers);
  }
  makeElement(tagName) {
    if (this.ns !== void 0 || tagName === "svg") {
      const ns = this.ns ?? "http://www.w3.org/2000/svg";
      const element = this.document.createElementNS(ns, tagName);
      this.append(element);
      return new DOMContext(this.document, element, void 0, ns, this.providers);
    } else {
      const element = this.document.createElement(tagName);
      this.append(element);
      return new DOMContext(this.document, element, void 0, this.ns, this.providers);
    }
  }
  getBooleanAttribute(name) {
    return this.element.hasAttribute(name);
  }
  setBooleanAttribute(name, value) {
    if (value) {
      this.element.setAttribute(name, "");
    } else {
      this.element.removeAttribute(name);
    }
  }
  createBooleanAttribute(name, value) {
    const current = this.element.hasAttribute(name);
    this.setBooleanAttribute(name, value);
    return [
      (newValue) => {
        this.setBooleanAttribute(name, newValue);
      },
      (removeTree) => {
        if (removeTree) {
          this.setBooleanAttribute(name, current);
        }
      }
    ];
  }
  getAttribute(name) {
    return this.element.getAttribute(name);
  }
  setAttribute(name, value) {
    if (value == null) {
      this.element.removeAttribute(name);
    } else {
      this.element.setAttribute(name, value);
    }
  }
  createAttribute(name, value) {
    const current = this.element.getAttribute(name);
    this.setAttribute(name, value);
    return [
      (newValue) => {
        this.setAttribute(name, newValue);
      },
      (removeTree) => {
        if (removeTree) {
          this.setAttribute(name, current);
        }
      }
    ];
  }
  getProperty(name) {
    return Reflect.get(this.element, name);
  }
  setProperty(name, value) {
    if (value == null) {
      Reflect.deleteProperty(this.element, name);
    } else {
      Reflect.set(this.element, name, value);
    }
  }
  createProperty(name, value) {
    const current = this.getProperty(name);
    this.setProperty(name, value);
    return [
      (newValue) => {
        this.setProperty(name, newValue);
      },
      (removeTree) => {
        if (removeTree) {
          this.setProperty(name, current);
        }
      }
    ];
  }
  createText(text) {
    const textNode = this.document.createTextNode(text);
    this.append(textNode);
    return [
      (newText) => {
        textNode.nodeValue = newText;
      },
      (removeTree) => {
        if (removeTree) {
          textNode.remove();
        }
      }
    ];
  }
  createClass(cls) {
    let current = extractClassNames(cls);
    current.forEach((className) => {
      this.element.classList.add(className);
    });
    return [
      (newClass) => {
        current.forEach((className) => {
          this.element.classList.remove(className);
        });
        current = extractClassNames(newClass);
        current.forEach((className) => {
          this.element.classList.add(className);
        });
      },
      (removeTree) => {
        if (removeTree) {
          current.forEach((className) => {
            this.element.classList.remove(className);
            if (this.element.classList.length === 0) {
              this.element.removeAttribute("class");
            }
          });
        }
      }
    ];
  }
  createHandler(name, handler) {
    this.element.addEventListener(name, handler);
    return (removeTree) => {
      if (removeTree) {
        this.element.removeEventListener(name, handler);
      }
    };
  }
  delayClear(f) {
    this.suspendedClears.push(f);
    return (removeTree) => {
    };
  }
  requestClear(removeTree, willClear) {
    if (this.suspendedClears.length === 0) {
      willClear();
      this.clear(removeTree);
    } else {
      const set = createIntegerSet(this.suspendedClears.length);
      const clearSuspended = (index) => {
        set.delete(index);
        if (set.size === 0) {
          willClear();
          this.clear(removeTree);
        }
      };
      this.suspendedClears.forEach((f, i) => {
        f(removeTree, () => {
          clearSuspended(i);
        });
      });
      this.suspendedClears.length = 0;
    }
  }
  clear(removeTree) {
    var _a, _b;
    if (removeTree) {
      if (this.reference !== void 0) {
        (_a = this.reference.parentElement) == null ? void 0 : _a.removeChild(this.reference);
      } else {
        this.element.onblur = null;
        (_b = this.element.parentElement) == null ? void 0 : _b.removeChild(this.element);
      }
    }
  }
  withProvider(mark, provider) {
    return new DOMContext(this.document, this.element, this.reference, this.ns, {
      ...this.providers,
      [mark]: provider
    });
  }
  getProvider(mark) {
    return this.providers[mark];
  }
  setStyle(name, value) {
    if (value == null) {
      this.element.style.removeProperty(name);
    } else {
      this.element.style.setProperty(name, value);
    }
  }
  createStyle(name, value) {
    const current = this.element.style.getPropertyValue(name);
    this.setStyle(name, value);
    return [
      (newValue) => {
        this.setStyle(name, newValue);
      },
      (removeTree) => {
        if (removeTree) {
          this.setStyle(name, current);
        }
      }
    ];
  }
};

// node_modules/@tempots/dom/render.js
function render(renderable, element) {
  const ctx = DOMContext.of(element);
  const clear = makeRenderable(renderable).appendTo(ctx);
  return () => {
    clear(true);
  };
}

// node_modules/@tempots/dom/helpers/is-empty-element.js
function isEmptyElement(element) {
  if (Array.isArray(element)) {
    if (element.length === 0)
      return true;
    return element.every(isEmptyElement);
  }
  return element == null || element === "";
}

// node_modules/@tempots/dom/helpers/handle-text-input.js
var handleTextInput = (f) => (e) => {
  const input = e.target;
  f((input == null ? void 0 : input.value) ?? "");
};

// node_modules/@tempots/dom/helpers/handle-anchor-click.js
function shouldNotApplyCallback(e, checkExtension, checkExternalUrl) {
  let target = e.target;
  while (target != null && !(target instanceof HTMLAnchorElement)) {
    target = target.parentElement;
  }
  if (target == null)
    return true;
  const anchor = target;
  if (e.button !== 0 || e.ctrlKey || e.metaKey) {
    return true;
  }
  if (anchor.target !== "_self") {
    return true;
  }
  if (anchor.getAttribute("download") != null) {
    return true;
  }
  if (checkExternalUrl) {
    const { pathname, search, hash } = anchor;
    const relativeUrl = pathname + search + hash;
    if (anchor.getAttribute("href") !== relativeUrl || checkExtension && !/\/[^/.]*$/.test(pathname)) {
      return true;
    }
  }
  return false;
}
var handleAnchorClick = (callback, options = {
  checkExtension: true,
  checkExternalUrl: true
}) => (e) => {
  const { checkExtension, checkExternalUrl } = options;
  if (shouldNotApplyCallback(e, checkExtension === true, checkExternalUrl === true)) {
    return;
  }
  if (callback())
    e.preventDefault();
};

// node_modules/@tempots/dom/components/animatable.js
function getComputedAnimatableProp(styles, key) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if (key === "translateX") {
    return new WebKitCSSMatrix(styles.transform).m41;
  } else if (key === "translateY") {
    return new WebKitCSSMatrix(styles.transform).m42;
  } else if (key === "translateZ") {
    return new WebKitCSSMatrix(styles.transform).m43;
  } else if (key === "rotateX") {
    return new WebKitCSSMatrix(styles.transform).m12;
  } else if (key === "rotateY") {
    return new WebKitCSSMatrix(styles.transform).m21;
  } else if (key === "rotateZ") {
    return new WebKitCSSMatrix(styles.transform).m31;
  } else if (key === "scaleX") {
    return new WebKitCSSMatrix(styles.transform).m11;
  } else if (key === "scaleY") {
    return new WebKitCSSMatrix(styles.transform).m22;
  } else if (key === "scaleZ") {
    return new WebKitCSSMatrix(styles.transform).m33;
  } else if (key === "skewX") {
    return new WebKitCSSMatrix(styles.transform).m13;
  } else if (key === "skewY") {
    return new WebKitCSSMatrix(styles.transform).m23;
  } else if (key === "grayScale") {
    return Number((_a = styles.filter.match(/grayscale\((\d+)%\)/)) == null ? void 0 : _a[1]);
  } else if (key === "sepia") {
    return Number((_b = styles.filter.match(/sepia\((\d+)%\)/)) == null ? void 0 : _b[1]);
  } else if (key === "saturate") {
    return Number((_c = styles.filter.match(/saturate\((\d+)%\)/)) == null ? void 0 : _c[1]);
  } else if (key === "hueRotate") {
    return Number((_d = styles.filter.match(/hue-rotate\((\d+)deg\)/)) == null ? void 0 : _d[1]);
  } else if (key === "invert") {
    return Number((_e = styles.filter.match(/invert\((\d+)%\)/)) == null ? void 0 : _e[1]);
  } else if (key === "brightness") {
    return Number((_f = styles.filter.match(/brightness\((\d+)%\)/)) == null ? void 0 : _f[1]);
  } else if (key === "contrast") {
    return Number((_g = styles.filter.match(/contrast\((\d+)%\)/)) == null ? void 0 : _g[1]);
  } else if (key === "blur") {
    return Number((_h = styles.filter.match(/blur\((\d+)px\)/)) == null ? void 0 : _h[1]);
  }
  return Number(styles.getPropertyValue(key));
}
function getComputedAnimatable(el, styles) {
  const result = {};
  const computedStyles = getComputedStyle(el);
  for (const [key, value] of Object.entries(styles)) {
    const k = key;
    if (value != null) {
      result[k] = getComputedAnimatableProp(computedStyles, k);
    }
  }
  return result;
}
function applyAnimatableProp(el, key, value) {
  if (value == null)
    return;
  if (key === "translateX") {
    el.style.transform += ` translateX(${value}px)`;
  } else if (key === "translateY") {
    el.style.transform += ` translateY(${value}px)`;
  } else if (key === "translateZ") {
    el.style.transform += ` translateZ(${value}px)`;
  } else if (key === "rotateX") {
    el.style.transform += ` rotateX(${value}deg)`;
  } else if (key === "rotateY") {
    el.style.transform += ` rotateY(${value}deg)`;
  } else if (key === "rotateZ") {
    el.style.transform += ` rotateZ(${value}deg)`;
  } else if (key === "scaleX") {
    el.style.transform += ` scaleX(${value})`;
  } else if (key === "scaleY") {
    el.style.transform += ` scaleY(${value})`;
  } else if (key === "scaleZ") {
    el.style.transform += ` scaleZ(${value})`;
  } else if (key === "skewX") {
    el.style.transform += ` skewX(${value}deg)`;
  } else if (key === "skewY") {
    el.style.transform += ` skewY(${value}deg)`;
  } else if (key === "grayScale") {
    el.style.filter += ` grayscale(${value}%)`;
  } else if (key === "sepia") {
    el.style.filter += ` sepia(${value}%)`;
  } else if (key === "saturate") {
    el.style.filter += ` saturate(${value}%)`;
  } else if (key === "hueRotate") {
    el.style.filter += ` hue-rotate(${value}deg)`;
  } else if (key === "invert") {
    el.style.filter += ` invert(${value}%)`;
  } else if (key === "brightness") {
    el.style.filter += ` brightness(${value}%)`;
  } else if (key === "contrast") {
    el.style.filter += ` contrast(${value}%)`;
  } else if (key === "blur") {
    el.style.filter += ` blur(${value}px)`;
  }
  el.style.setProperty(key, String(value));
}
function applyInterpolatedAnimatableProp(el, key, from, to, progress) {
  if (from != null && to != null) {
    const value = from + (to - from) * progress;
    applyAnimatableProp(el, key, value);
  }
}
function applyInterpolatedAnimatable(el, from, to, progress) {
  el.style.transform = "";
  el.style.filter = "";
  for (const [key, value] of Object.entries(to)) {
    const k = key;
    applyInterpolatedAnimatableProp(el, k, from[k], value, progress);
  }
}
function applyAnimatable(el, styles) {
  el.style.transform = "";
  el.style.filter = "";
  for (const [key, value] of Object.entries(styles)) {
    if (value != null) {
      applyAnimatableProp(el, key, value);
    }
  }
}

// node_modules/@tempots/dom/components/Provider.js
var ProviderImpl = class {
  constructor(mark, provider, children) {
    __publicField(this, "mark");
    __publicField(this, "provider");
    __publicField(this, "children");
    __publicField(this, "appendTo", (ctx) => {
      const newCtx = ctx.withProvider(this.mark, this.provider);
      const clear = makeRenderable(this.children).appendTo(newCtx);
      return (removeTree) => {
        newCtx.requestClear(removeTree, () => {
          clear(removeTree);
        });
      };
    });
    this.mark = mark;
    this.provider = provider;
    this.children = children;
  }
};
function Provider({ mark, value, children }) {
  return new ProviderImpl(mark, value, children);
}
var ConsumerImpl = class {
  constructor(mark, children) {
    __publicField(this, "mark");
    __publicField(this, "children");
    __publicField(this, "appendTo", (ctx) => {
      const provider = ctx.getProvider(this.mark);
      if (provider == null) {
        throw new Error("No provider found for mark");
      }
      const clear = makeRenderable(this.children(provider)).appendTo(ctx);
      return (removeTree) => {
        clear(removeTree);
      };
    });
    this.mark = mark;
    this.children = children;
  }
};
function Consumer({ mark, children }) {
  return new ConsumerImpl(mark, children ?? (() => []));
}

// node_modules/@tempots/dom/components/FadeIn.js
var FadeInImpl = class {
  constructor(end, start, duration, delay) {
    __publicField(this, "end");
    __publicField(this, "start");
    __publicField(this, "duration");
    __publicField(this, "delay");
    this.end = end;
    this.start = start;
    this.duration = duration;
    this.delay = delay;
  }
  appendTo(ctx) {
    const el = ctx.getElement();
    const start = (() => {
      if (this.start != null) {
        applyAnimatable(el, this.start);
        return this.start;
      } else {
        return getComputedAnimatable(el, this.end);
      }
    })();
    const startTime = Date.now() + this.delay;
    const { duration, end } = this;
    let nextFrameId = null;
    function frame() {
      const now = Date.now();
      if (now < startTime) {
        nextFrameId = requestAnimationFrame(frame);
        return;
      }
      const progress = Math.min((now - startTime) / duration, 1);
      applyInterpolatedAnimatable(el, start, end, progress);
      if (progress < 1) {
        nextFrameId = requestAnimationFrame(frame);
      } else {
        nextFrameId = null;
      }
    }
    frame();
    return (_) => {
      if (nextFrameId != null)
        cancelAnimationFrame(nextFrameId);
    };
  }
};
function FadeIn(props) {
  const { start, duration, delay, ...end } = props;
  return new FadeInImpl(end, start, duration ?? 200, delay ?? 0);
}

// node_modules/@tempots/dom/components/FadeOut.js
var FadeOutImpl = class {
  constructor(end, duration, delay) {
    __publicField(this, "end");
    __publicField(this, "duration");
    __publicField(this, "delay");
    this.end = end;
    this.duration = duration;
    this.delay = delay;
  }
  appendTo(ctx) {
    const el = ctx.getElement();
    const { duration, end } = this;
    return ctx.delayClear((removeTree, clear) => {
      const start = getComputedAnimatable(el, this.end);
      const startTime = Date.now() + this.delay;
      function frame() {
        const now = Date.now();
        if (now < startTime) {
          requestAnimationFrame(frame);
          return;
        }
        const progress = Math.min((now - startTime) / duration, 1);
        applyInterpolatedAnimatable(el, start, end, progress);
        if (progress < 1) {
          requestAnimationFrame(frame);
        } else {
          clear();
        }
      }
      requestAnimationFrame(frame);
    });
  }
};
function FadeOut(props) {
  const { duration, delay, ...end } = props;
  return new FadeOutImpl(end, duration ?? 200, delay ?? 0);
}

// node_modules/@tempots/dom/components/Repeat.js
var RepeatImpl = class {
  constructor(times, children) {
    __publicField(this, "times");
    __publicField(this, "children");
    __publicField(this, "appendTo", (ctx) => {
      const newCtx = ctx.makeReference();
      const count = this.times.get();
      const clears = new Array(count);
      for (let i = 0; i < count; i++) {
        clears[i] = this.children(i).appendTo(newCtx);
      }
      const cancel = this.times.subscribe((newCount) => {
        while (newCount < clears.length) {
          clears.pop()(true);
        }
        for (let i = clears.length; i < newCount; i++) {
          clears[i] = this.children(i).appendTo(newCtx);
        }
      });
      return (removeTree) => {
        newCtx.requestClear(removeTree, () => {
          cancel();
          clears.forEach((clear) => {
            clear(removeTree);
          });
        });
      };
    });
    this.times = times;
    this.children = children;
  }
};
function Repeat(props) {
  return new RepeatImpl(props.times, props.children ?? (() => Fragment({ children: [] })));
}

// node_modules/@tempots/dom/components/OnRemove.js
var OnRemoveImpl = class {
  constructor(clear) {
    __publicField(this, "clear");
    __publicField(this, "appendTo", () => {
      return (removeTree) => {
        this.clear(removeTree);
      };
    });
    this.clear = clear;
  }
};
function OnRemove(props) {
  return new OnRemoveImpl(props.clear);
}

// node_modules/@tempots/dom/components/For.js
function For({ of, children: render2 }) {
  const times = of.map((v) => v.length);
  return new RepeatImpl(times, (index) => {
    const value = of.at(index);
    return new FragmentImpl([
      makeRenderable(render2 == null ? void 0 : render2(value, index)),
      new OnRemoveImpl(value.clean)
    ]);
  });
}

// node_modules/@tempots/dom/components/HiddenWhenEmpty.js
var HiddenWhenEmptyImpl = class {
  appendTo(ctx) {
    ctx.setStyle(":empty", "display: none");
    return (removeTree) => {
      if (removeTree)
        ctx.setStyle(":empty", null);
    };
  }
};
function HiddenWhenEmpty() {
  return new HiddenWhenEmptyImpl();
}

// node_modules/@tempots/dom/components/OneOf.js
var OneOfImpl = class {
  constructor(match, cases) {
    __publicField(this, "match");
    __publicField(this, "cases");
    __publicField(this, "appendTo", (ctx) => {
      const pair = this.match.get();
      let key = pair[0];
      const value = pair[1];
      const stableCtx = ctx.makeReference();
      let prop = new Prop(value);
      let newCtx = stableCtx.makeReference();
      let clear = makeRenderable(this.cases[key](prop)).appendTo(newCtx);
      const cancel = this.match.subscribe(([newKey, newValue]) => {
        if (newKey !== key) {
          newCtx.requestClear(true, () => {
            newCtx = stableCtx.makeReference();
            key = newKey;
            prop.clean();
            prop = new Prop(newValue);
            clear(true);
            clear = makeRenderable(this.cases[key](prop)).appendTo(newCtx);
          });
        } else {
          prop.set(newValue);
        }
      });
      return (removeTree) => {
        newCtx.requestClear(removeTree, () => {
          cancel();
          prop.clean();
          stableCtx.requestClear(removeTree, () => {
          });
        });
      };
    });
    this.match = match;
    this.cases = cases;
  }
};
function OneOf(props) {
  return new OneOfImpl(props.match, props);
}

// node_modules/@tempots/dom/components/If.js
function If({ is, then, otherwise }) {
  return new OneOfImpl(is.map((v) => v ? [1, true] : [2, false]), {
    1: () => then,
    2: () => otherwise
  });
}
function When({ is, children }) {
  return new OneOfImpl(is.map((v) => v ? [1, true] : [2, false]), {
    1: () => children,
    2: () => null
  });
}
function Unless({ is, children }) {
  return new OneOfImpl(is.map((v) => v ? [1, true] : [2, false]), {
    1: () => null,
    2: () => children
  });
}

// node_modules/@tempots/dom/components/InnerHTML.js
var InnerHTMLImpl = class {
  constructor(html) {
    __publicField(this, "html");
    __publicField(this, "appendTo", (ctx) => {
      const el = ctx.getElement();
      const previous = el.innerHTML;
      el.innerHTML = this.html.get() ?? "";
      const cancel = this.html.subscribe((value) => {
        el.innerHTML = value ?? "";
      });
      return (removeTree) => {
        cancel();
        if (removeTree) {
          el.innerHTML = previous;
        }
      };
    });
    this.html = html;
  }
};
function InnerHTML({ html }) {
  return new InnerHTMLImpl(html);
}

// node_modules/@tempots/dom/components/Lifecycle.js
var LifecycleImpl = class {
  constructor(onMount, onUnmount) {
    __publicField(this, "onMount");
    __publicField(this, "onUnmount");
    __publicField(this, "appendTo", (ctx) => {
      this.onMount(ctx.getElement());
      return () => {
        this.onUnmount(ctx.getElement());
      };
    });
    this.onMount = onMount;
    this.onUnmount = onUnmount;
  }
};
function Lifecycle({ onMount, onUnmount }) {
  return new LifecycleImpl(onMount ?? (() => {
  }), onUnmount ?? (() => {
  }));
}

// node_modules/@tempots/dom/components/Match.js
var MatchImpl = class {
  constructor(on, using, matches) {
    __publicField(this, "on");
    __publicField(this, "using");
    __publicField(this, "matches");
    __publicField(this, "appendTo", (ctx) => {
      let newCtx = ctx.makeReference();
      const value = this.on.get();
      let key = value[this.using];
      let derived = this.on.map((v) => v);
      let renderable = makeRenderable(this.matches[key](derived));
      let clear = renderable.appendTo(newCtx);
      const cancel = this.on.subscribe((newValue) => {
        const newKey = newValue[this.using];
        if (newKey === key)
          return;
        newCtx.requestClear(true, () => {
          clear(true);
          derived.clean();
          key = newKey;
          derived = this.on.map((v) => v);
          newCtx = newCtx.makeReference();
          renderable = makeRenderable(this.matches[key](derived));
          clear = renderable.appendTo(newCtx);
        });
      });
      return (removeTree) => {
        newCtx.requestClear(removeTree, () => {
          cancel();
          derived.clean();
          clear(removeTree);
        });
      };
    });
    this.on = on;
    this.using = using;
    this.matches = matches;
  }
};
function Match({ on, using, matches }) {
  return new MatchImpl(on, using, matches);
}

// node_modules/@tempots/dom/components/NotEmpty.js
function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function NotEmpty({ on, display, whenEmpty }) {
  return makeElement(If, { is: on.map((v) => (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Array.isArray(v) ? v.length > 0 : v != null && !isEmpty(v)
  )), then: display, otherwise: whenEmpty });
}

// node_modules/@tempots/dom/components/Portal.js
var PortalImpl = class {
  constructor(selector, children) {
    __publicField(this, "selector");
    __publicField(this, "children");
    this.selector = selector;
    this.children = children;
  }
  appendTo(ctx) {
    const element = ctx.getDocument().querySelector(this.selector);
    if (element === null) {
      throw new Error(`Cannot find element by selector: ${this.selector}`);
    }
    return render(makeRenderable(this.children), element);
  }
};
function Portal(props) {
  return new PortalImpl(props.selector, props.children);
}

// node_modules/@tempots/dom/components/Show.js
var ShowImpl = class {
  constructor(on, otherwise, children) {
    __publicField(this, "on");
    __publicField(this, "otherwise");
    __publicField(this, "children");
    __publicField(this, "appendTo", (ctx) => {
      const condition = this.on.map((v) => v != null);
      const el = makeRenderable(makeElement(If, { is: condition, then: this.children(this.on), otherwise: this.otherwise }));
      return el.appendTo(ctx);
    });
    this.on = on;
    this.otherwise = otherwise;
    this.children = children;
  }
};
function Show({ when, children, otherwise }) {
  return new ShowImpl(when, otherwise, children ?? (() => makeElement(makeFragment, {})));
}

// node_modules/@tempots/dom/components/TextContent.js
var TextContentImpl = class {
  constructor(value) {
    __publicField(this, "value");
    __publicField(this, "appendTo", (ctx) => {
      const el = ctx.getElement();
      const previous = el.textContent;
      el.textContent = this.value.get() ?? "";
      const cancel = this.value.subscribe((value) => {
        el.textContent = value ?? "";
      });
      return (removeTree) => {
        cancel();
        if (removeTree) {
          el.textContent = previous;
        }
      };
    });
    this.value = value;
  }
};
function TextContent({ value }) {
  return new TextContentImpl(value);
}

export {
  makeProviderMark,
  DOMContext,
  render,
  isEmptyElement,
  handleTextInput,
  handleAnchorClick,
  getComputedAnimatableProp,
  getComputedAnimatable,
  applyAnimatableProp,
  applyInterpolatedAnimatableProp,
  applyInterpolatedAnimatable,
  applyAnimatable,
  ProviderImpl,
  Provider,
  ConsumerImpl,
  Consumer,
  FadeInImpl,
  FadeIn,
  FadeOutImpl,
  FadeOut,
  RepeatImpl,
  Repeat,
  OnRemoveImpl,
  OnRemove,
  For,
  HiddenWhenEmptyImpl,
  HiddenWhenEmpty,
  OneOfImpl,
  OneOf,
  If,
  When,
  Unless,
  InnerHTMLImpl,
  InnerHTML,
  LifecycleImpl,
  Lifecycle,
  MatchImpl,
  Match,
  NotEmpty,
  PortalImpl,
  Portal,
  ShowImpl,
  Show,
  TextContentImpl,
  TextContent
};
//# sourceMappingURL=chunk-S4NFCYOW.js.map
